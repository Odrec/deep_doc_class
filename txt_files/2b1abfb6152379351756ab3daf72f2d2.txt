Informatik C

Grundlagen der Technischen Informatik

Prof. Dr.-Ing. Werner Brockmann, M. Sc. Jonas Schneider
¨Ubung 12 - Stoppuhr auf dem ATmega16
Abgabe bis Di, 27.01.2015, 14:00 Uhr in der Vorlesung

Hinweis: Schicken Sie, zus¨atzlich zu Ihrer schriftlichen Abgabe, bitte Ihre Assemblerpro-
gramme per Mail an Ihren Tutor, damit diese auch getestet und im Testat vorgef¨uhrt werden
k¨onnen.

Assembler-Coding-Style

Da wir uns nun mit realen Prozessoren besch¨aftigen und diese mehr M¨oglichkeiten bie-
ten, durch Strukturierungen oder Namensvergaben lesbaren Code zu schreiben, ist folgender
Coding-Style einzuhalten:

• F¨ur verwendete Register sind sinnvolle Namen zu benutzen.
• Variablennamen und Registernamen sind selbsterkl¨arend und werden klein geschrieben

und bei Bedarf durch Unterstriche getrennt, z.B. segment nr, timer5, clock time.
• S¨amtliche Initialisierungen stehen einheitlich am Anfang einer Programmeinheit.
• Unterprogrammnamen, Makronamen und Konstanten werden GROSS geschrieben (und

ggf. durch Unterstriche getrennt), z.B. LOAD PATTERN, WAIT 5 MS.

• Sprungziele innerhalb von Makros, Unterprogrammen oder dem Hauptptogramm wer-
den dagegen nur am Anfang groß geschrieben (und durch Unterstriche getrennt), z.B.
Load Pattern 1:, End of UP:.

• Die ¨Ubersichtlichkeit wird durch Einr¨uckungen unterst¨utzt.
• Ausf¨uhrliche Dokumentation aller Programmteile: Zu Beginn von Unterprogrammen
und Makros werden Ein- und Ausgabeparameter mit deren Zweck und Datentyp (und
ggf. dem zul¨assigen Wertebereich), sowie eine kurze Funktionsbeschreibung (’Was’ soll
das UP machen bzw. ’Wie’ arbeitet der Algorithmus) als Kommentar angegeben. Details
der implementierten Funktionen werden dann im Coderumpf kommentiert.

• Bei Unterprogrammen und Makros ist grunds¨atzlich auf Seiteneﬀektfreiheit zu achten.
• Falls nicht anders angegeben, endet das Programm in einer Endlosschleife.

Hinweise zur Assemblerprogrammierung auf dem ATmega16

• Schreiben Sie vollst¨andige Programme, die an Adresse 0 (Reset-Interrupt) starten. D.h.
beachten Sie, dass Sie vor der Verwendung des Stacks den Stackpointer initialisieren
m¨ussen. Ebenso m¨ussen alle Register vor Ihrer Verwendung initialisiert werden. Ihre
Programme m¨ussen ausf¨uhrbar und simulierbar sein.

• Benutzen Sie zur einfacheren Programmﬂusskontrolle die Branch-Anweisungen, die auf

die verschiedenenen Flags des ATmega16 pr¨ufen.

• Verwenden Sie f¨ur einfache Abfragen die einfachen Skip-Befehle statt der komplexeren

Branch-Befehle.

1

Einfache Stoppuhr

Im Folgenden soll mit dem ATmega16 eine einfache 1-Minuten-Stoppuhr umgesetzt werden.
Diese erh¨alt ¨uber den Pin PD2 ein Taktsignal mit einer Frequenz von 1 Hz. Die Stoppuhr
verwaltet in einem Register den aktuellen Z¨ahlerstand in Form gepackter BCD-Zahlen f¨ur die
10er und 1-er Sekundenstellen. Das bedeutet, dass die Zehnerstelle im High-Nibble und die
1er-Stelle im Low-Nibble des Registers abgelegt werden.
¨Uber zwei weitere Pins wird die Stoppuhr gesteuert. Ein positives Signal an Pin PA0 soll die
Stoppuhr auf 0 Sekunden asynchron zur¨ucksetzen. Ein positives Signal an Pin PA1 pausiert
die Stoppuhr, w¨ahrend ein negatives Signal die Stoppuhr laufen l¨asst.
Die Ausgabe des Stoppuhrstandes erfolgt fortlaufend ¨uber eine zweistellige 7-Segment-Anzeige.
Der Z¨ahlerstand soll von 59 Sekunden wieder auf 0 Sekunden ¨uberlaufen und den ¨Uberlauf
an Pin PA2 durch einen 1-Puls von 1 Sekunde signalisieren. Neben diesem Signal gibt die
Stoppuhr ¨uber Pin PA3 ein Alive-Signal aus, das zyklisch wechselt und so anzeigt, dass das
Programm auf dem ATmega16 noch korrekt arbeitet.
Die Zeit soll zun¨achst mit Hilfe des externen Taktsignals an Pin PD2 gez¨ahlt werden. Paral-
lel dazu wird die 10er und 1er Stelle st¨andig 7-Segment-codiert ausgegeben. Die 10er-Stelle
wird dazu an Port B und die 1er-Stelle an Port C ausgegeben. Die BCD-codierten Zahlen
m¨ussen somit in die entsprechenden 7-Segment-Codes umgewandelt werden. Diese sind in
einer Tabelle im Datenspeicher abgelegt.
Hinweis: Die Aufgaben dieses ¨Ubungsblattes bauen teilweise aufeinander auf, lassen sich
jedoch auch separat l¨osen (unter der Annahme, dass entsprechende Unterprogramme oder
Makros aus vorhergehenden Aufgabenteilen vorliegen.

Aufgabe 12.1:

Systemstruktur

(6 + 4 = 10 P)

a) Zeichnen Sie ein Modulbild der auf dem ATmega16 realisierten Stoppuhr. Machen Sie in
dem Modulbild kenntlich, welche Funktionalit¨at ¨uber welchen Port nach außen gef¨uhrt
ist.

b) Stellen Sie einen Registerbelegungsplan auf, der festh¨alt, welche Register f¨ur welche

Aufgaben verwendet werden.

Aufgabe 12.2:

Konﬁguration der I/O-Ports

(10 P)

Zun¨achst sollen die Ein- und Ausgabeports f¨ur das Programm konﬁguriert werden. Schreiben
Sie hierzu ein seiteneﬀektfreies Unterprogramm INIT PORTS, in dem Pin PA0 und PA1 an
Port A als Eingang mit internem Pull-Up und Pin PA2 sowie PA3 als Ausgang konﬁguriert
werden, ohne die restliche Konﬁguration des Ports zu ver¨andern. Port B und Port C sollen
vollst¨andig als Ausgang konﬁguriert werden. Konﬁgurieren Sie zus¨atzlich Pin PD2 als Eingang
ohne internen Pull-Up, ohne die restliche Konﬁguration des Ports zu ver¨andern.

Aufgabe 12.3:

Ausgabe der 7-Segment-Codes

(10 P)

Nun soll ein seiteneﬀektfreies Unterprogramm SSEG OUT geschrieben werden, das den ge-
genw¨artigen Z¨ahlerstand der Stoppuhr durch eine im Speicher abgelegte Lookup-Table in
zwei 7-Segment-Codes ¨uberf¨uhrt und diese auf den Ports B und C ausgibt. Legen Sie dazu
die Lookup-Table im Datenspeicher des ATmega16 ab und greifen Sie mit Hilfe eines der
Indexregister geschickt auf die Tabelle zu. Starten Sie die Tabelle an ihrer Basisadresse mit
dem Bitmuster f¨ur die Ausgabe der 0 und legen Sie die weiteren Ziﬀern aufsteigend dahinter
ab. Geben Sie die Ansteuerungen der Segmente auf den Pins 0 bis 6 der Ports aus, wobei Pin
0 dem Segment a und Pin 6 dem Segment g entspricht. F¨ur eine Auﬂistung der verschiedenen
7-Segment-Muster k¨onnen Sie Aufgabe 5 auf dem 3. Aufgabenblatt heranziehen.

2

