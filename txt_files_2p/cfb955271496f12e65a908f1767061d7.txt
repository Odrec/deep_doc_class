Uni Osnabrück / Theoretische Informatik

Prof. Dr. M. Chimani

Algorithmen II — Übungsblatt 2

Wintersemester 2014/15 — Ausgabe 27. Okt. — Besprechung 7. Nov.

Aufgabe 2.1: Super Stack – Pseudocode
Betrachten Sie einen Stack mit beschränkter Größe M und den üblichen Operationen push und
pop. Falls solch eine Operation nicht durchgeführt werden kann weil der Stack zu voll bzw. leer
ist, erfolgt eine Fehlermeldung. Zusätzlich haben wir eine Operation superpop(k). Dabei werden
min{a, k} Elemente vom Stack gelöscht und als Liste ausgegeben, wobei a die derzeitige Anzahl
an Elementen am Stack bezeichnet.
Geben Sie eine Implementierung dieser Datenstruktur in Pseudocode an.

Aufgabe 2.2: Super Stack – Analyse
Betrachten Sie die Datenstruktur der obigen Aufgabe.

(a) Analysieren Sie die Laufzeiten der drei Operation klassisch.

(b) Zeigen Sie mittels amortisierter Analyse, dass bei einer beliebigen Folge von n Operatio-

nen, jede Operation (auch superpop) amotisiert nur O(1) Zeit benötigt.

Aufgabe 2.3: Binäres Inkrementieren
Betrachten Sie den Fall, dass ein Counter initial k viele 1er-Bits gesetzt hat, bevor n Increment-
Operationen aufgerufen werden. Mittels der Potentialmethode haben wir in der Vorlesung ge-
zeigt, unter welchen Bedingungen dennoch amortisierte Kosten von nur O(1) entstehen. Zeigen
Sie das selbe mittels der Buchhaltermethode.

Aufgabe 2.4: Rotierende Bäume
Erinnern Sie sich an die Rotationen bei AVL-Bäumen.
Gegeben zwei beliebige binäre Suchbäume (nicht notwendigerweise balanciert) mit n Schlüsseln
und gleicher Schlüsselmenge. Zeigen Sie, dass Sie den ersten Baum mittels O(n) Rotationen in
den zweiten verwandeln können.
Hinweis. Formen Sie den Baum zunächst in eine möglichst einfache kanonische Form um.

Aufgabe 2.5: B-Baum
Beschreiben Sie, wie man in einem B-Baum die Operationen predecessor, successor, minimum
und maximum eﬃzient – also mit Laufzeit O(1) – realisieren kann.

Aufgabe 2.6: Finden des Maximums
Gegeben eine Folge von n Zahlen, die zunächst monoton steigt und dann streng monoton fällt.
Geben Sie einen O(log n)-Algorithmus an, der das Maximum in dieser Zahlenfolge ﬁndet.

