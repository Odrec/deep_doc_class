4.2.3  Minimierung partiell definierter Schalt-
funktionen 
 
Für  einige  Variablenbelegungen  ist  bei  partiell  definierten 
Schaltfunktionen der Funktionswert nicht definiert (bzw. belie-
big  0  oder  1,  d.h.  “don’t  care“),  z.  B.  weil  eine  Kombination 
von Eingangssignalen nicht auftreten kann. Folglich kann das 
Ausgangssignal für don´t cares geeignet gewählt werden, um 
eine Schaltfunktion zu minimieren.  

f: S → B mit S ⊂ Bn     B = {0,1} 

 
Beispiel:  

 

a  b  c  d  f(a, b, c, d) 
0  0  0  0 
0  0  0  1 
0  0  1  0 
0  0  1  1 
0  1  0  0 
0  1  0  1 
0  1  1  0 
0  1  1  1 
1  0  0  0 
1  0  0  1 
1  0  1  0 
1  0  1  1 
1  1  0  0 
1  1  0  1 
1  1  1  0 
1  1  1  1 

1 
1 
0 
0 
1 
x 
1 
0 
1 
1 
1 
x 
x 
x 
0 
1 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

00
1

1

c, d

00

01

11

10

a, b

01
1

11
x

x

1

x

1

10
1

1

x

1

x = don’t care

 

Universität 
Osnabrück 

GTI 
4 - 17 

AG Technische 
Informatik 

Minimierung im KV-Diagramm: 
 
Don’t  care-Terme  können  leicht  zur  Minimierung  verwendet 
werden,  indem  sie  selektiv  (virtuell)  so  auf  1  gesetzt  werden, 
dass  möglichst  große  ´1´-Felder  entstehen.  Sie  können,  müs-
sen aber nicht für die Bildung von möglichst großen ´1´-Feldern 
berücksichtigt werden.  
 
 

a, b 

00  01  11  10 
1 
1 

1 

1 

1 

1 

 
 

00 

01 

c, d 

11 

10 

1 

1 

1 

1 

1 

1 

d b a 

c 

ad 

b a 

 

 
 
 
 
 
 
 

f

+=

c

ad

+

dbaba

+

 

(LV(f) = 8) 

statt 

=

f

dbadbacb

+

+

+

abcd

 

(LV(f) = 12) 

 ohne Ausnutzung von don´t cares bzw.  
  bei don’t care = 0 

Universität 
Osnabrück 

GTI 
4 - 18 

AG Technische 
Informatik 

Systematische Vorgehensweise bei der KV-
Minimierung: 
 
 
Ziel: 

 
   Mit möglichst wenig Feldern alle Einsen der Funk-

tion erfassen  
   möglichst große Felder finden  

 
 
 
 
Strategie:  Erst  wesentliche  Primimplikanten  ermitteln,  dann 
minimale  Restüberdeckung.  D.  h.,  mit  möglichst 
wenig Schritten alle Einsen erfassen.  

  

 
Schritte: 
 

(1)  Wähle einen Minterm (eine 1), der noch nicht abge-

deckt ist. 

 

 
(2)  Betrachte die benachbarten Einsen und don´t cares 
dieses Minterms und nutze sie zum maximalen Ver-
schmelzen.  
Falls der so entstandene Term ein einziger Term den 
ausgewählten  Minterm  abdeckt,  ist  dieser  Term  ein 
wesentlicher  Primimplikant  und  muss  in  die  DMF 
aufgenommen werden. 

 
(3)  Wiederhole  (1)  und  (2),  bis  alle  wesentlichen  Prim-

implikanten gefunden worden sind. 

 
(4)  Suche  eine  minimale  Menge  von  Primimplikanten, 
die  alle  übrigen,  noch  nicht  abgedeckten  Minterme 
(Einsen) überdecken. Gibt es mehrere solcher Men-
gen, wähle die mit den wenigsten Variablen (minima-
le Restüberdeckung). 

Universität 
Osnabrück 

GTI 
4 - 19 

AG Technische 
Informatik 

4.2.4  Konjunktive Minimalform (KMF) 
 
Analog zur DMF enthält die konjunktive Minimalform KMF die 
minimale  Anzahl  von  Variablen  und  Termen  in  konjunktiver 
Normalform (KNF). 
Sie bietet sich für Schaltfunktionen mit wenigen ´0´ bzw. einer 
„günstigen“ Anordnung der ´0´ an.  
 
KV-Diagramm mit Mintermen: 
Zusammenfassen der Felder mit “0” minimiert  f  statt f, d. h.  
f  liegt als DMF vor. Anwendung des De Morganschen Geset-
zes liefert dann f in KMF. 
 
Beispiel: 

a, b
1
0

0
1

10
1

0

c

 

0
1

0

c 

0

1

 

 

DMF:   
 
DMF von f : 
 
De Morgan:  
 
KMF von f 

0

0

a

f

=

cbca

+

 

f

f

+=

c

ab

+=

c

ab

 
=

ab*c

 

=

  

)ba(c

+

 

Universität 
Osnabrück 

GTI 
4 - 20 

AG Technische 
Informatik 

KV-Diagramm mit Maxtermen 
 
Analog zum KV-Diagramm für Minterme lassen sich auch KV-
Diagramme für Maxterme konstruieren. 
 

0
1

0

c

0

1

a, b
1
0

0
1 

0 

0

Maxterme, z. 
cba
cba

++
++

1
1

0

a +
b 
KM

c
)ba(c

+

=

f:

 

 
 
Die Maxterme können dann analog zu Mintermen mittels der 
Beziehung 
 

+

x(

x)(y

+

)y

=

x

 

 
zusammengefasst  und  damit  die  KMF  direkt  bestimmt  wer-
den. 
 
Minimierung partiell definierter Schaltfunktionen in konjunkti-
ver Minimalform analog zur DNF.  
 
 
Weiteres graphisches Minimierungsverfahren: 
 
 

Händlerscher Kreisgraph (bis 5 Variable) 

Universität 
Osnabrück 

GTI 
4 - 21 

AG Technische 
Informatik 

Quine-McCluskey 
 
Ausgangsbasis: Satz von Quine  
 

Sei f ≠ 0. Dann besteht eine Minimalform einer Schalt-
funktion f ausschließlich aus Primimplikanten von f.  

Schritte: 
 
I.  Erstellen der disjunktiven kanonischen Normalform (DKN)  
 
II.  Ermitteln der Primimplikanten 

 

4.2.5  Algorithmisches Verfahren nach 

 

 

 

 

-  Einteilen  der  Minterme  in  Klassen  Ki,  wobei  Ki  alle 

Minterme mit i nichtnegierten Variablen enthält. 

-  Zusammenfassen von Mintermen benachbarter Klas-

sen gemäß 
  

+

=

x

. 

xy

yx

 
-  Verschmolzene Minterme werden abgehakt. 
-  Die  neu  entstandenen  Terme  höherer  Ordnung  wer-
den ggf. weiter verschmolzen und abgehakt, bis keine 
weitere Zusammenfassung möglich ist. 

-  Nicht  mehr  verschmelzbare  Terme  bzw.  Minterme 
sind die gesuchten Primimplikanten (auch Primterme 
genannt). 

 

III.  Bestimmen der wesentlichen Primimplikanten 

(wesentlich:  enthält  als  einziger  einen  der  Minterme 
und muss daher unbedingt verwendet werden) 

 

IV. Auswahl der minimalen Restüberdeckung 

(d.h.  der  durch  die  wesentlichen  Primimplikanten 
nicht  abgedeckten  Minterme  mittels  unwesentlicher 
Primimplikanten) 

Universität 
Osnabrück 

GTI 
4 - 22 

AG Technische 
Informatik 

 

f

=

+

ab

Beispiel: 
 
 
 
 
Schritt I:    DKN bilden 
 
Erweitern analog zu: 
 
 
 
       DKN 

=

 
f

ab

=
=

+
abc
 
abcd

cab
+
dcab

+

abc

d

+

dcab

 
 
 

d

+

+

+

+
 
abcd
cdbadcbadcbadcba
dcbadcbadcba

dcab
+
+

abc
+
+

dcab
+

+

cbadbadcbcba

 

+

+

+

 
 
 
Schritt II:    Ermitteln der Primimplikanten  
 
Teilschritt a:  Bilde eine Tabelle und trage in die erste Spalte 
die  binär  dargestellten  Indizes  aller  Minterme 
von f sortiert nach der Anzahl der Einsen.  

 
Teilschritt b:  Fasse  Terme  aus  benachbarten  Gruppen,  die 
sich  nur  in  einer  Stelle  unterscheiden,  zusam-
men und markiere sie.  

 
Teilschritt c:  Wiederhole bis keine Terme mehr zusammenge-

fasst werden können.  

 
Zum Verschmelzen verwendete Terme können abgehakt 
werden.  
Die am Ende verbleibenden Terme sind die Primimplikanten.  

 

Universität 
Osnabrück 

GTI 
4 - 23 

AG Technische 
Informatik 

Schritt II: Primimplikanten 
 

verschmol- 

zene Minterme neue Terme

Klasse 

# 

 

0 

Minterme 

dcba

 

K0 

K1 

K2 

K3 

K4 

 

1 

 

2 

 

 

 

8 

3 

 

5 

10 

 

12 

 

13 

 

 

 

14 

 

15 

dcba

 

dcba

 

 

 

dcba

 

cdba

 

 

 

dcba

 

dcba

 

 

 

dcab

 

dcab

 

 

 

dabc  

 

abcd 

Universität 
Osnabrück 

 

0,1 

 

0,2 

 

 

 

0,8 

1,3 

2,3 

1,5 

2,10 

8,10 

8,12 

 

5,13 

 

12,13 

 

10,14 

 

12,14 

 

13,15 
14,15 

cba

 

dba

 

 

 

dcb

 

dba

 

cba

 

dca

 

dcb

 

dba

 

dca

 

dcb  

cab  

dac  

dab  

 

abd 
abc  

 

 

GTI 
4 - 24 

verschmol- 
zene Terme 

 

0,1 - 2,3 

 

0,2 - 1,3 

 

0,2 - 8,10 

 

0,8 - 2,10 

neue 
Terme 

ba  

ba  

db  

db  

 

 

 

 

8,10 - 12,14 

8,12 - 10,14 

 

 

 

 

 

 

da  

da  

 

 

 

12,13 - 14,15 

 

ab  

 

 

 

 

 

12,14 - 13,15 

 

ab  

 

 

 

 

AG Technische 
Informatik 

Schritt III:    Wesentliche Primimplikanten identifizieren  
 
Die Primimplikanten werden in einer Matrix, der Primimplikan-
tentabelle, den Mintermen gegenüber gestellt, d.h. alle Min-
terme angekreuzt, die in einem Primimplikanten enthalten 
sind.  
 
Primimplikantentabelle: (Überdeckungsmatrix) 
 

 

Prim- 
impl. 
 
dca
dcb  
ba  
db  
da  
ab 
 
Anmerkung:  Ein x kennzeichnet hier die Überdeckung eines 

8  10 12 13  14  15 WP
 
 
 
 
 
 
  ←
 
x 
 
 
 
x 
 
x  ←
 

Minterme 
5 
x 
x 
 
 
 
 

1 
x 
 
x 
 
 
 

0 
 
 
x 
x 
 
 

2 
 
 
x 
x 
 
 

3 
 
 
x 
 
 
 

 
 
 
x 
x 
 

 
 
 
 
x 
x 

 
 
 
 
x 
x 

 
x 
 
 
 
x 

Minterms mit einem Primimplikanten.  

 

 

m0, m1, m2 und m3 

 
Wenn z. B. Primimplikant  ba  in die DMF aufgenommen wird, 
dann werden die Minterme 
 
abgedeckt, d.h. genau dann 1, wenn 
 
Wesentliche  Primimplikanten  (Kernimplikanten,  Hauptterme) 
decken als einzige einen Minterm ab und müssen daher ver-
wendet werden.  
 
Das sind hier  
15 abdecken. 
Universität 
Osnabrück 

,  da sie als einzige die Minterme 3 bzw. 

AG Technische 
Informatik 

1ba =  ist. 

GTI 
4 - 25 

abba ,

 

Die durch die Primimplikanten abgedeckten Minterme können 
gestrichen werden.  
 
Primimplikantentabelle:  
 

 
x 
 
 
 
x 

 
 
 
 
x 
x 

 
 
 
 
x 
x 

 
 
 
x 
x 
 

3 
 
 
x 
 
 
 

2 
 
 
x 
x 
 
 

0 
 
 
x 
x 
 
 

1 
x 
 
x 
 
 
 

Minterme 
5 
x 
x 
 
 
 
 

8  10 12 13  14  15 WP
 
 
 
 
 
 
  ←
 
 
 
x 
x 
 
 
x  ←
 

Prim- 
impl. 
 
dca
dcb  
ba  
db  
da  
ab 
 
 
Schritt IV:    Minimale Restüberdeckung bestimmen  
 
Die  wesentlichen  Primimplikanten  und  die  durch  sie  abge-
deckten Minterme werden aus der Primimplikantentabelle ent-
fernt.  
 
Die noch nicht durch die wesentlichen Primimplikanten abge-
deckten  Minterme  müssen  durch  eine  minimale  Menge  der 
unwesentlichen Primimplikanten überdeckt werden. 
 

 

 

| 

8 

10 

|  5 

 
---------------------------------------------- 
dca
dcb
db  
da  
---------------------------------------------- 

x 
x   
 
 

  | 
  | 
| 
| 

 
 
x 
x 

 
 
x 
x 

| 
| 
| 
| 

 

 

Universität 
Osnabrück 

GTI 
4 - 26 

AG Technische 
Informatik 

Bei einfachen Schaltfunktionen kann die minimale Restüber-
deckung unmittelbar aus der Tabelle bestimmt werden. 
 
Minimierte Schaltfunktion (DMF) 
Die  DMF  enthält  die  Disjunktion  aus  allen  wesentlichen  Pri-
mimplikanten und die unwesentlichen Primimplikanten aus ei-
ner  minimalen  Restüberdeckung.  Für  letzteres  gibt  es  oft 
mehrere (hier 2 • 2) gleichwertige Lösungen.  
 
 

Hier:      

ab

  

+

ba

=

f

dca
+



dcb



db
+



da



 
 
Wenn  die  Restüberdeckung  nicht  so  offensichtlich  zu  finden 
ist  wie  hier,  können  folgende  Regeln  systematisch  rekursiv 
angewendet werden:  
 
Spaltendominanz: 

Eine Spalte Si einer Primimplikantentabelle dominiert eine 
Spalte Sj, wenn sie mindestens in allen Zeilen einen Ein-
trag  hat,  für  die  auch  die  Spalte  Sj  einen  Eintrag  besitzt. 
D.h.,  jeder  Primplikant  (Zeile),  der  Spalte  Sj  überdeckt, 
überdeckt auch Spalte Si.  
  Die dominierende Spalte Si kann entfernt werden.  

 
Zeilendominanz:  

Eine Zeile Pi dominiert eine Zeile Pj, wenn sie mindestens 
alle Spalten der Zeile Pj überdeckt.  
  Dominierte Zeile Pj löschen. 
  Bei gleicher Anzahl abgedeckter Spalten die Zeile mit 

den höheren Kosten löschen.  

Universität 
Osnabrück 

GTI 
4 - 27 

AG Technische 
Informatik 

1. Schritt: Bestimmung der wesentlichen Primimplikanten  
 

  
  

  
  
  
  
X 
X 

X  X 
  
  
  
  
  
  
  
X 
  
  

  
  
  
  
X  X 
  
  
  
  
  
X 

X  X 
  
  
P1 
X  X  X 
P2 
  
P3  X 
  
  
  
P4  X  X  X  X 
P5 
  
  
P6 
  
  
und Eliminieren der Primimplikanten sowie der dadurch 
abgedeckten Minterme  
P1 
  
X  X 
  
X  X  X 
  
P2 
P3  X 
  
  
P4  X  X  X  X 
  
P5 
  
  
P6 
  
  

  
  
  
  
X  X 
  
  
  
  
X 
  

X  X 
  
  
  
  
  
  
X 
  
  
  

  
  
  
  
X 
X 

  
  
X 

  
  

  
  
X 

  
  

  
X 
  

X 
  

  
X 
  

X 
  

  
  
  
  

  
  
  
  

  
  

 
2. Schritt: Spaltendominanz   3. Schritt: Zeilendominanz 
Entfernen aller Minterme 
im Rest, die einen anderen  
Minterm dominieren  
 

Entferne alle Primterme, die  
durch einen anderen, nicht  
längeren dominiert werden 

 
 

P2  X  X 
P4  X  X 
P5  X 
P6 
  

    X 
    X 

 
 
 
 

 
 
 
 

 
 
 
 

P2  X 
P4  X 
  
P5 
P6 
  

X 
X 

 Minimal ist die Lösung: P1, P3, P2, P5. 

Universität 
Osnabrück 

GTI 
4 - 28 

AG Technische 
Informatik 

Systematische Bestimmung der minimalen Restüberde-
ckung 
 
Es  gibt  weitere  systematische  Verfahren  zum  Auffinden  der 
minimalen Restüberdeckung (programmierbar), die vor allem 
bei komplexeren Schaltfunktionen angewandt werden. 
 
 
Beispiel: Verfahren von Petrick 
 
(1)  Ordne  den  Zeilen  der  Tabelle  mit  den  unwesentlichen 
Primimplikanten die (virtuellen) Schaltvariablen P1, P2, ...  
 
 
zu. 
 

Beispiel: 

  0  1  2  5  6  7   

_____________________________________________________ 

 

 

 

 
P1  ba    x 
P2  ca    x 
P3  cb   
 
P4  cb   
 
P5  ac   
 
P6  ab  
 

 

 

 

 

x 
 
x 
 
 
 

 
x 
 
x 
 
 

 
 
x 
 
x 
 

 
 
 
x 
 
x 

 
 
 
 
 
 
 
 
x   
x   

_____________________________________________________ 

 
(2)  Bilde  eine  „Schaltfunktion“  P,  die  1  liefert,  wenn  alle 

Spalten (Minterme) abgedeckt sind.  

P  ist  eine  Konjunktion  von  ODER-verknüpften  Termen 
(Pi0  +  Pi1  +  ...),  wobei  die  Pi0,  Pi1,  ...  denjenigen  Zeilen 
entsprechen, die die Spalte i überdecken (KNF).  
Hier muss also gelten:  
    P = (P1+P2)(P1+P3)(P2+P4)(P3+P5)(P4+P6)(P5+P6) = 1 

 
 

 
 

Universität 
Osnabrück 

GTI 
4 - 29 

AG Technische 
Informatik 

(3)  Minimiere  diese  Schaltfunktion  P  durch  Ausmultiplizieren 
und  Reduktion  mittels  X+XY=X  (relativ  einfach,  da  keine 
negierten Terme): 
P = P1P4P5 + P1P2P5P6 + P2P3P4P5 + P1P3P4P6 + P2P3P6 

 
 
 
(4)  Jeder  Term  steht  für  eine  Menge  von  unwesentlichen 

Primimplikanten, die jeweils alle Minterme überdecken. 
  Wähle  diejenigen  Terme  mit  der  geringsten  Anzahl 

von Variablen aus: 

P1P4P5 ,  P2P3P6 

 

 

 
 

 

 

D. h., die Primimplikanten P1, P4 und P5 bzw. alternativ 
P2, P3 und P6 decken jeweils alle Minterme ab.  

ac

+

+

=

=

+

+

ab

 

cbbaF

 
(5)  Bestimme für jeden dieser Terme die Anzahl von Schalt-
variablen  in  der  zugehörigen  DNF  aus  unwesentlichen 
Primimplikanten. Das Minimum entspricht der gesuchten 
minimalen Restüberdeckung, in diesem Beispiel also: 
 

 
 
 
 
 
(6)  Die  gesuchte  disjunktive  Minimalform  DMF  kann  nun 
bestimmt werden, indem die wesentlichen Primimplikan-
ten  noch  zu  einer  der  Funktionen  F  mit  der  minimalen 
Restüberdeckung hinzugenommen werden. 

   oder 

 
mit je 6 Schaltvariablen. 

cbbaF

 

 
Für Handauswertung bei größeren Schaltfunktionen recht müh-
sam, aber leicht programmierbar. Das Verfahren von Petrick hat 
allerdings  exponentielle  Laufzeit.  Für  die  Logiksynthese  kom-
plexer Schaltnetze werden deshalb in der Praxis oft Verfahren 
angewendet, die nur eine "gute" Lösung liefern.  

Universität 
Osnabrück 

GTI 
4 - 30 

AG Technische 
Informatik 

Minimierung partiell definierter Schaltfunktionen mittels Quine-
McCluskey: 
 
Veranschaulichung im KV-Diagramm: 
 
Beispiel: 

ba
0

a, b
01 1
1

1
x

1

x

1

x

1

x

x

0

0
c, d 
1

c a

1

 

 
 
Zunächst alle Don’t care-Terme „virtuell“ auf 1 setzen und die 
nichtredundanten Minterme (also nicht die don´t cares) mar-
kieren. (Hier sind sie fett gedruckt.) 
 
 
 
f(a,b,c,d) = m2 + m3 + m4 + m5 + m6 + m7 + m8 + m11 + m15 
 
 

(mi: Minterm i, z. B. 

dcbam2 =

) 

Universität 
Osnabrück 

GTI 
4 - 31 

AG Technische 
Informatik 

Verschmelzung 

Ermittlung der Primimplikanten (Schritt II) 
 
 

 

K1 

K2 
 

 

2,3  0 0 1 - 2,3 - 6,7 
2,6  0 - 1 0 2,6 - 3,7 
4,5  0 1 0 - 4,5 - 6,7 
4,6  0 1 - 0 4,6 - 5,7 
3,7  0 - 1 1 3,7 - 11,15 
- 0 1 1 3,11 - 7,15 

#  Minterme  Verschmelzung 
2  0 0 1 0  
4  0 1 0 0  
8  1 0 0 0  
 
3  0 0 1 1  
5  0 1 0 1   3,11 
6  0 1 1 0  
5,7  0 1 - 1
6,7  0 1 1 -
 
7  0 1 1 1   7,15 
- 1 1 1
11  1 0 1 1   11,15  1 - 1 1

 

Primimp.
ca    

0 - 1 -  
0 - 1 -    
0 1 - -  
 
dcba
0 1 - -   ba   
- - 1 1   cd 
- - 1 1    
 
 
 
 
 

 
 
 
 
 

 
 
 
 
 

 

 

K3 
 
K4  15  1 1 1 1  
 
Bei Schaltfunktionen mit Redundanzen werden redundante 
Minterme zwar in die Tabelle aufgenommen und zum Ver-
schmelzen verwendet, aber nicht bei der Ermittlung der Prim-
implikanten berücksichtigt.  
 
Deshalb ergibt sich hier: 
 
 
 
 
Bemerkung:  Hier alternative Form der Tabelle mit Darstellung 

                 f =  ca  +  ba  

der Minterme als Bitvektoren  
Bei Verschmelzung steht ‘-’ für weggefallene Va-
riablen.  

GTI 
4 - 32 

AG Technische 
Informatik 

 

Universität 
Osnabrück 

Wesentliche Primimplikanten (Schritt III) 
 
Nur ’echte’ (notwendige) Minterme übernehmen, denn die 
don´t care-Terme dienen nur der Vereinfachung (Verschmel-
zung) und sind keine Primimplikanten.  
 

ca
ba

wesentlich
wesentlich

 

Minterme

2
x

4

x

5

x

6
x

x

Prim-
implik.
ca
ba
cd

dcba

 
 
 
 
 
Restüberdeckung (Schritt IV) 
 
 
 
 
 
 
 
 
 

und damit ist 

entfällt hier 

baca

+

(vgl. KV-Diagramm) 

 

         

f(a,

d)c,b,

=

 

 

Universität 
Osnabrück 

GTI 
4 - 33 

AG Technische 
Informatik 

4.3  Minimierung von Schaltnetzen mit meh-

reren Ausgängen 

 
Die  Minimierung  der  einzelnen  Schaltfunktionen  liefert  bei 
Schaltnetzen  mit  mehreren  Ausgängen  meist  nicht  die  mini-
male Lösung für das gesamte Schaltnetz (Anzahl Gatter, An-
zahl Leitungen), da häufig Teile der Schaltung mehrfach ge-
nutzt werden können.  
Meist ist es das primäre Ziel, die Anzahl von Gattern zu reduzie-
ren, und dann erst die Anzahl der Leitungen.  
 
Beispiel: 
 
 

 

f(a, b, c) = (y1, y2, y3) 
 
y1
 
y2
+
y3
 

cbacba
abc
bcacbacba
bca
cbacba

=
=
=

+
+
+

+
+
+

cab

+

abc

 

Einzelminimierung mit KV-Diagramm 
 

y1 :
0
1 

c

0 

1 

a, b
1

0

1 

=

y 1 

ab

+ 
c b 

1
1

ab

c

0

1

cb

y2:
0
1

a, b
1

0

1

1
1 

=

ba

y2

+

c b 

y3 :
0

c

0 

1 

0

a, b
1
1 

1 

1 

1
1

1

+=

ba

y 3 

Universität 
Osnabrück 

GTI 
4 - 34 

 

AG Technische 
Informatik 

Realisierung mit UND/ODER-Gattern: 

 

a b c

b

c

b

c

a

b c

b

c

a

&

&

&

&

&

1≥

1≥

1≥

y1

y2

y3

 

 
Vereinfachung durch Mehrfachbenutzung von Termen,  
hier: 

 (siehe auch KV-Diagramm) 

b

c

a

b c

b

c

a

 

)cb(
a b c

&

&

&

&

1≥

y1

Universität 
Osnabrück 

1≥

y2

GTI 
4 - 35 

1≥

y3

 

AG Technische 
Informatik 

 

 

+

y3

abc

+=

a

+=

a)aa(bc

Weitere Vereinfachung durch Abkehr von DMF für y3: 
          
          (siehe auch KV-Diagramm) 
 
Minimale Schaltung: 
 
a b c

bcaa

+=

a

b c

+

bca

b

c

 

a

&

&

&

1≥

1≥

1≥

y1

y2

y3

 

 
 
Schaltnetze  mit  Verzweigungen  heißen  auch  vermaschte 
Schaltnetze. 
 
Terme,  die  in  mehreren  Schaltfunktionen  des  Schaltnetzes 
auftreten heißen Koppelterme. 
(hier z. B.: 
 
 
 
Es  gibt  systematische  Verfahren,  die  die  Minimierung  von 
Schaltnetzen  unter  Berücksichtigung  von  Koppeltermen  er-
lauben. 

bca,cb

) 

Universität 
Osnabrück 

GTI 
4 - 36 

AG Technische 
Informatik 

Mehrfach-Ausgangs-Minimierung mit KV-Diagrammen 
 
Beispiel 
y 1: 
0

f(a, b, c) = (y1, y2) 

a b c

0

a, b
1
1

1

c 

0 

1 

c 

0 

1 

1 

1

y 1

=

a

+ 
b

a, b
1

0

1

y 2: 
0
1

1

1 

y 2

=

+

ba 

c a 

&

&

&

&

y 1

1≥

y 2

1≥

Unabhängige Realisierung ohne Koppelterme

 

1

a b c

 

y1:
0

c

0 

1 

0

a, b 
1
1 

1 

1 

Koppel

ter

y 1

= a

bc a +

a, b 
1

0

1

y2:
0
1 

1 

1 

c

0 

1 

Koppel

ter

y 2

= ba 

bca +

&

&

&

y1

y2

1≥

1≥

Minimierte Schaltung mit Koppelterm

 

Universität 
Osnabrück 

GTI 
4 - 37 

AG Technische 
Informatik 

Systematische Ermittlung der Koppelterme auch als Prim-
implikanten der m-Produktfunktionen 
 
Vorgehensweise (KV-Diagramme oder Quine-McCluskey) 
 
(1)  Bilde  alle  Produktfunktionen  aus  m  =  2,  3,  ...  n  Ausgangs-

funktionen (m-Produktfunktionen mit 2 ≤ m ≤ n). 

(2)  Ermittle die Primimplikanten der Produktfunktionen (Kandida-

ten für Koppelterm). 

(3)  Ermittle  die  bereits  durch  die  wesentlichen  Primimplikanten 
außerhalb der Produktfunktionen abgedeckten Minterme der 
Einzelfunktionen. 

(4)  Decke  die  restlichen  Minterme  der  Einzelfunktionen  durch 
eine minimale Menge der Primimplikanten der Produktfunkti-
onen ab. 

 
Beispiel: m = 2 
 
 

y 1 : 
00  01 

a, b 

11  10
1 

c 

0 

1 

c 

0 

1 

1 

1 

= 
y 1 

ab 

+ 
bc 

a, b 

y 2 : 
00  01 
1 

11  10

1 

1 

= 

b a 

+ 
c a 

y 2 

c

0

1

10

Koppel-

term

y1

y1:
00  01 

a, b 

11  10
1 

1 

1 

= 

bc a 

+ 
ab 

abgedeckt

durch

wesentl. PI

c

0

1

a, b 

y2:
00  01 
1

11  10

1

1 

= 

bc a 

+ 
b a 

y2

Koppel-

term

abgedeckt

durch

wesentl. PI

 

y 1 y 2:
00  01

a, b

11

c 

0 

1 

1

bca

y y  21  = 
2-Produktfunktion 
mit Koppelterm 
(Primimplikant 
 der Prod.fkt.) 

 
Sehr  hohe  Komplexität:  2n-n-1  Produktfunktionen!  Daher  meist 
heuristische Verfahren (z. B. Espresso II), die nicht unbedingt das 
absolute Minimum, aber eine „gute“ Lösung finden. 

Universität 
Osnabrück 

GTI 
4 - 38 

AG Technische 
Informatik 

Rechenschaltungen 

4.4 
 
4.4.1  Addierer 
 
Halbaddierer 
 
Ein Halbaddierer addiert zwei einstellige  
Binärzahlen zu einem Summenbit S und 
einem Übertragsbit Ü. 
 
A

Ü

HA

 

A 
0 
0 
1 
1 

 

B 
0 
1 
0 
1 

 

S 
0 
1 
1 
0 

 

Ü 
0 
0 
0 
1 

=

+

(A

⋅

)AB(B)

 

=

+

S

 

B
 
 
Schaltfunktionen dazu: 
 
+
 

=⊕=
=

BABABAS
Ü

AB

 
 
Realisierung mit Grundgattern unter Nutzung von Koppelterm 
AB und alternative Realisierung mit 
 

AB

BA

: 

S

 A 

B 

& 

≥ 1 

& 

B
A

Ü

S

    
 

S

 

Universität 
Osnabrück 

GTI 
4 - 39 

AG Technische 
Informatik 

Volladdierer 
 
Ein Volladdierer berücksichtigt auch einen Übertrag Ci-1 (Car-
ry) von der niederwertigeren Stelle i-1.  
 
Durch Kaskadierung können so beliebig breite Addierer reali-
siert werden.  
 
 

Ai
Bi
Ci-1

VA

Si

Ci

 
 
 
 
 
 

Ai Bi Ci-1  Si  Ci
0  0  0  0  0 
0  0  1  1  0 
0  1  0  1  0 
0  1  1  0  1 
1  0  0  1  0 
1  0  1  0  1 
1  1  0  0  1 
1  1  1  1  1 

 
 
 
 
 
Schaltfunktion:  
 
 
 
 
 
 
 
 

AS
i

=
=

C

=

i

i

i

i

i

i

B
CBA

⊕⊕
+

i

−
1i

C
1-i
CBA

i

i

+

−
1i

CBA

i

i

+

−
1i

CBA

i

i

−
1i

CABA

+

i

+

CB

i

−
1i

−
1i

 

Universität 
Osnabrück 

GTI 
4 - 40 

AG Technische 
Informatik 

Schaltung gemäß DNF 
 

 A i 

B i C i-1 

i A 

iB 

C i-1 

iA  B i 

1iC − 

A i 

i B 

i C − 
1 

& 

& 

& 

& 

≥ 1 

S i 

 

 A i 

B i 

A i 

C i-1 

B i 

C i-1 

& 

& 

& 

≥ 1 

C i 

GTI 
4 - 41 

 

AG Technische 
Informatik 

 
 
 

Universität 
Osnabrück 

 

HA 

A i B i C i-1 

 
Beispiel: 
 
 A i 

Volladdierer aus 2 Halbaddierern 
 

Ü 1

HA 

Ü 2

≥ 1 

C i 
S i  

B i 

i A 

iB 

C i-1 

i C − 
1 

& 

& 

& 

& 

≥ 1 

≥ 1 

   “Propagate“ 
P i  = A i  

⊕  B i 

G i  = A i B i 
“Generate“ 

 
Vergleich: 

≥ 1 

C i 

S i 

 

9 Gatter; 2 Gatterlaufzeiten: 2 τ 
Volladdierer:  
2 Halbaddierer:  7 Gatter; 4 Gatterlaufzeiten: 4 τ  
 

Anmerkung:  Hier vereinfachte Laufzeitbetrachtung durch 

Einheitsverzögerung τ (Unit Delay) pro Gatter.  

Universität 
Osnabrück 

GTI 
4 - 42 

AG Technische 
Informatik 

4.4.2  Paralleladdierer 
 
Paralleladdierer  bilden  die  Summen  der  jeweiligen  Binärstel-
len parallel und lassen den Übertrag durch die Stufen von der 
niederwertigsten  bis  zur  höchstwertigen  Stelle  fortpflanzen 
(Ripple-Carry- oder Carry-Chain-Addierer). 
 
 

 

SN-1 

S3

S2

S1

S0 

CN-1 

VA 

C3 

• • • 

VA

C2

VA

C1

VA

C0 

VA 

C-1

BN-1 

AN-1 

B3

A3

B2

A2

B1 

A1

B0

A0 

 

 
 
Nachteil: 

 
Additionszeit:  2N τ 
 
           bzw. 

Es muss gewartet werden, bis der Übertrag bis 
zur  (N-1)-ten  Stelle,  also  durch  N  Stufen, 
durchgelaufen ist. 

(Volladdierer-Realisierung) 

(2N + 2) τ  (Halbaddierer-Realisierung) 

Universität 
Osnabrück 

GTI 
4 - 43 

AG Technische 
Informatik 

Voraus-Ermittlung von Überträgen 
(Parallele Überlauflogik,”carry look-ahead”) 
 
Ziel: 

Laufzeitreduktion durch schnellere Generierung der 
Carry-Signale  

 
Ansatz:  Hilfsschaltung zur parallelen Generierung der Carry-
Signale unter Ausnutzung der Hilfsvariablen Gi und 
Pi der Zwischenergebnisse  

 
Übertrag der Stufe i: 
 
 
 
 

 
 

Ci = Ai Bi + (Ai ⊕ Bi) Ci-1 
    = Gi + Pi Ci-1 

 
Alle  Überträge  lassen  sich  damit  prinzipiell  in  nur  2  Gatter-
laufzeiten vorab ermitteln. 

Universität 
Osnabrück 

GTI 
4 - 44 

AG Technische 
Informatik 

Gi = Ai Bi    
Pi = Ai ⊕ Bi 

gibt an, ob Carry erzeugt wird  (“generate“) 
gibt an, ob Carry weitergegeben (= 1) oder  
absorbiert (= 0) wird  
(“propagate“) 

 
 
Leicht aus Halbaddierer-Realisierung zu gewinnen (s. o.). 
 
Für einzelne Überträge gilt damit: 
 
C0 = G0 + P0C-1 
C1 = G1 + P1C0 = G1 + P1G0 + P1P0C-1 
C2 = G2 + P2C1 = G2 + P2G1 + P2P1G0 + P2P1P0C-1 
C3 = G3 + P3C2 = G3 + P3G2 + P3P2G1 + P3P2P1G0 + P3P2P1P0C-1 

 • 
 • 
 • 

Beispiel:  ÜES 

 

 

(Übertragungs-Ermittlungs-Schaltung,  Car-
ry-Look-Ahead-Generator) für 4-Bit Addierer 
mit Propagate/Generate-Ausgängen 

S3 A3  B3 

S2 A2 B2

S1 A1 B1

S0  A0  B0

VA 3 

VA 2

VA 1

VA 0

P3 

C2 

G3 
≥1 

P2

G2

C1

P1

≥1

C0

G1
≥1

P0 

G0 

C-1

G 

≥1 

 

l

i

e
a
n
g
s
k
c
o
B

l

&

&

&

& 

& 

& 

&

&

&

P 

 
 
Ripple Carry: 

   

& 

C-1

 

  8 τ, 36 Gatter 
10 τ, 28 Gatter 

(Volladdierer) 
(Halbaddierer) 

 
Carry look-ahead:  6 τ, 28 + 14 = 42 Gatter  (Halbaddierer) 
 
→ Der Aufwand wächst von Stelle zu Stelle überproportional.  
Universität 
Osnabrück 

AG Technische 
Informatik 

GTI 
4 - 45 

Größere Wortlängen 
 
Die vollständige Vorabermittlung des Übertrags ist theoretisch 
möglich, aber zu aufwendig bei großen Wortbreiten. 
 
Deshalb Kaskadierung von ÜES (meist Blöcke mit 4 Bit) 
 

= G + PC-1 

C3  = G3 + P3G2 + P3P2G1 + P3P2P1G0 + P3P2P1P0C-1 
 
 
G =   G3 + P3G2 + P3P2G1 + P3P2P1G0  Block-Generate 
Block-Propagate 
P =   P3P2P1P0 

 
Zusammenfassung  von  Blöcken  mit  gleicher  ÜES  für  breite 
Addierer möglich. 
 
Beispiel:  16-Bit  Addierer  mit  4-Bit  ÜES  (mit  weiterem  4-Bit  
 
 

ÜES zu 64 Bit kaskadierbar) 

 

15 

14 

13 

12 

11 

10 

9 

8 

7 

6 

5 

4 

3 

2 

1 

0 

4 τ

ÜES 

P 

G 

C 

ÜES 
G 

P 

ÜES 

P 

G 

C 

C 
ÜES 

P  G 

ÜES 

4 τ

P 

G 

C 

C-1 

2 τ

 

   C15 = G+PC-1 
 
Addierzeit:  
 
Ripple-Carry:  32 τ 
34 τ 

10 τ 

   

Aufwand: 182 Gatter 

Aufwand: 144 Gatter (Volladdierer) 
Aufwand: 112 Gatter (Halbaddierer) 

Universität 
Osnabrück 

GTI 
4 - 46 

AG Technische 
Informatik 

sierung

g als In

tegrier

rte Sch

haltung
g  

s TTL-IC

C ist de

er SN74

483-Ba

ustein 

und se

i-

Realis
 
Die Re
ne Var

ealisieru
ung als
. 
rianten.

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 47

AG T

Technische
e 
Informatik
k 

4.4.3  Subtraktion 
 
Prinzipien: 

Schaltnetz  

- Subtraktion analog zu Addierer in speziellem 

 
 
  

- Subtraktion durch Addition des Komplements  
  (benötigt mehr Operationen, aber am häufig- 
   sten weil meist in Kombination mit Addierer) 

 
Negative Zahlen in Komplementdarstellung: 
 
 
 
 
 
Addierer / Subtrahierer (Zweierkomplement) 
(Addition bei Sub/Add = 0, Subtraktion bei Sub/Add = 1)  

Einerkomplement:  C-1 = CN-1 (Einserrücklauf) 
Zweierkomplement: C-1 = 1, CN-1 ignorieren. 

 

SN-1 

• • • 

S0 

CN-1 

N-Bit Addierer

C-1 

= 1 

• • • 

= 1 

AN-1 BN-1 

A0 B0

Sub/Add

 

 
Durch Sub/Add = 1, also C-1 = 1, wird aus dem Einerkomple-
ment von B ein Zweierkomplement. 
 
Bit CN-1 ist das Vorzeichen des Ergebnisses. 
 
Negative Differenz S = A - B richtig im Zweierkomplement. 
Universität 
Osnabrück 

AG Technische 
Informatik 

GTI 
4 - 48 

4.4.4  Multiplikation  
 
Für kleinere Wortbreiten kann die Multiplikation direkt in 
einem Schaltnetz vorgenommen werden.  
 
Prinzip:  Stellengewichtete Addition abhängig von 

Multiplikator-Bits  

Nur positive Zahlen; Verallgemeinerung auf 
negative Zahlen möglich. 

M = (mN-1, mN-2, ... m0)2 ; Q = (qN-1, qN-2, ..., q0)2 

 
Hier: 

 
 
 

⋅

QM

=

⋅

i Mq

⋅

i

2

 

−
N
1

=
i
0
 
 

 
 
 
 
 

M ⋅ 2i  Schieben um i Stellen nach links 

  qi ⋅ M  entspricht qi ∧ (mN-1, mN-2, ... m0)2 

  0 1 1 1  x  1 1 0 1 
                  0 1 1 1 
 
 

 
 
 
 
Vergleiche Multiplikation per Hand: 
 
Beispiel:  
 
 
 
 
 
 
 
 
 
 
 
 
Realisierung der N Additionen mit N Addierern aus je N 
Volladdierern (Ripple-Carry Adder), die verschoben hinter-
einander geschaltet sind. Die jeweiligen Partial-Produkte PPi 
werden stufenweise geeignet gesteuert durch die 
Multiplikator-Bits qi über UND-Gatter aufaddiert. 
Universität 
Osnabrück 

AG Technische 
Informatik 

0 0 0 0 

0 1 1 1 

    0 1 1 1_____ 
1 0 1 1 0 1 1 

GTI 
4 - 49 

Aufbau

u:  Stru
mitte
Volla

kturell e
els einh
addiere

einfach
heitliche
er und U

he, VLS
er, einfa
UND-G

SI-freun
acher Z
atter. 

dliche 
Zellen a

Realisi
aus 

erung 

el: Asyn

nchron

er viers

stelliger

r Parall

el-Mult

tiplizier

er 

 
 
Beispie
 

0

m3

0

m2

Multip

plikand
0

m1

0

m0

q
q0
0
0

p0

q1
0
Mul

tiplikator

p
p1

q2
0

q3
0

p2

PP4

4 = Produkt
t

and: 
Aufwa
N2 Ze
ellen aus 
-Gatter (d
UND-
eiche Sh
Vergle
og N) mit
O(N lo
Looka
ahead, O
y 
Carry
 
edarf: 
Zeitbe
τ für U
UND-Gat
ddierer, d
Vollad
= (2N - 2
TMUL  
=
= (4N - 1

 

Volladdie
erer plus
d.h. O(N2
)) 
ift/Add-M
Mul.:  
t Carry- 
O(N) mit R

Ripple-

e 2τ für  

tter sowie
d. h. 
2) 2τ + 3τ
τ 
) τ = O(N
N) 

Partialpr
(PP

rodukt  0
P0)

PP1

PP2

P
PP3

p7

p

6

p5

p4

p3

 

 

 
 
 
 
 

 

 
 
 

 

 
 

Universitä
ät 
ck 
Osnabrüc

Vergle
O(N lo
O(N2) 

eiche Shif
og N) mit 
mit Rippl

ft/Add-Mu
Carry- Lo
le-Carry  

ul.: 
ookahead

d,  

GTI
4
4 - 50

AG T

Technische
e 
Informatik
k 

Die Schaltnetz-Realisierung ergibt schnelle asynchrone 
Multiplizierer (Combinational Array Multiplier).  
 
Es ist keine Ablaufsteuerung/Kontrolleinheit erforderlich!  
 
Der Hardwareaufwand ist bei heutiger Integrationsdichte von 
integrierten Schaltungen für kleine bis mittlere Wortbreiten 
akzeptabel. 
 
 
Weitere schnelle Algorithmen für Multiplizierer bekannt: z. B. 
Carry-Save Multiplikation, Algorithmen mit Zusammenfassung 
von Bitgruppen wie der Booth-Algorithmus, der gleich mehrere 
benachbarte Bits des Multiplikators gleichzeitig betrachtet.  
 
 
 
Weil der Hardwareaufwand aber quadratisch mit der Wortbreite 
wächst, wird die Multiplikation für größere Wortbreiten nicht 
mehr in einem Schritt in einem Schaltnetz berechnet, sondern 
auf aufeinander folgende stellengewichtete Additionen in der 
selben Hardwareeinheit mit Zwischenspeichern der 
Zwischenergebnisse abgebildet.  
 
Für diese mehrschrittige („sequentielle“) Verarbeitung reichen 
in Hardware nur ein Addierer und ein Zwischenspeicher sowie 
ein Steuerwerk (s. unten), das die Abfolge der Verarbeitungs-
schritte und das Speichern von Zwischenergebnissen 
kontrolliert.  
 
Bei einer solchen mehrschrittigen Realisierung 
(„Rechenwerke“) sind auch Multiplikationen von 
vorzeichenbehafteten und von Fest- sowie Gleitpunktzahlen 
leicht bei vertretbarem Hardwareaufwand zu realisieren (s. 
unten).  
Universität 
Osnabrück 

AG Technische 
Informatik 

GTI 
4 - 51 

ALUs (Arithmetic Logical Units) und 
Rechenwerke 

4.5 
 
 
Arithmetisch-Logischen-Einheiten (ALUs) sind Schaltnetze, die 
typischerweise folgende Operationen ausführen: 
 
 
 

Arithmetische Operationen: 

Addition, Subtraktion, ggf. Multiplikation 

 
 
 
 
 

   und 
Logische Operationen: 

UND, ODER, Exklusiv-ODER,  
Schieben (links, rechts),  
Löschen, Negation eines Operanden  

 
 
Häufig verwendetes Symbol für eine ALU: 

1. Operand

2. Operand

Steuersignale 
vom Steuerwerk

(Status-) 
Flags 

Ergebnis

Universität 
Osnabrück 

GTI 
4 - 52 

AG Technische 
Informatik 

Die Auswahl der auszuführenden Operationen wird durch 
entsprechende Steuersignale von einem übergeordneten 
Steuerwerk vorgenommen.  
 
Dieses koordiniert auch die Bereitstellung und Abholung der 
Daten (Operanden) sowie das Zwischenspeichern von 
Zwischenergebnissen. 
 
Durch einen geeigneten übergeordneten Ablauf (im 
Steuerwerk) können sämtliche Operationen durch eine ALU 
ausgeführt werden. Sie ist deshalb als eine 
"Universalschaltung" das Kernstück sämtlicher Computer.  
 
 
I. d. R. generiert eine ALU auch Statussignale ("Flags"), die 
dem Steuerwerk spezielle Kriterien anzeigen, z. B. Vorzeichen, 
Ergebnis = 0 oder Überlauf.  
 
 
Für größere Wortbreiten kann eine ALU auch in Module 
aufgeteilt werden, die kleinere Bitgruppen (Bitscheiben, "Bit-
Slices") parallel verarbeiten und entsprechend der 
gewünschten Wortbreite kaskadiert werden. Sie erhalten die 
Steuersignale gemeinsam.  
 
 

Universität 
Osnabrück 

GTI 
4 - 53 

AG Technische 
Informatik 

sierung

g als In

tegrier

rte Sch

haltung
g  

Realis
 
Eine R
ist der 

Realisie
SN741

rung ei
181-Bau

iner kas
ustein u

skadier
und sei

rbaren 4
ine Var

4 Bit-A
ALU als 
. 
rianten.

TTL-IC
C 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 54

 

AG T

Technische
e 
Informatik
k 

181-Realisieru

ung als

SN741
 

s Integgrierte SSchaltu

ung  

 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 55

AG T

Technische
e 
Informatik
k 

Rechenwerke 
 
Komplexere Operationen wie Multiplikation und Division werden 
aus Aufwandsgründen meist in mehreren Schritten realisiert,  
d. h. auf eine Sequenz (Ablauf) von einfacheren durch eine 
einfache Hardware, z.B. eine ALU, realisierbaren Operationen 
abgebildet.  
 
Die Kombination von ausführender Hardware (Operationswerk) 
und Steuerwerk (Ablaufsteuerung; Control unit) nennt man 
Rechenwerk.  
 
Rechenwerke verfügen i.d.R. über Speicher („Register“) für 
Zwischenergebnisse.  
 
Sie können eigenständige Bausteine, Coprozessoren oder 
Bestandteile von Mikroprozessoren sein.  
 
 
Beispiel: Multiplizier-Rechenwerk 
 

System

bus

Accumulator AC

Multiplier-quotient

register MQ

(Memory) data

register DR

Parallel adder

and

logic circuits

 

Universität 
Osnabrück 

GTI 
4 - 56 

Flags

. . .

Control

unit

 

AG Technische 
Informatik 

Beispiel: Gleitkomma-Rechenwerk 
 

Input
bus

E1

E2

M1

M2

Shifter 1

Adder 2

R

E1 - E2

Zero digit
checker

Adder

1

Adder

3

E3

Exponent
comparison

and

mantissa
alignment

Mantissa
addition-
subtraction

Shifter 2

Result

normalization

M3

 

Output

bus

 
Getrenntes Exponenten- und Mantissenrechenwerk. 
 
Ein Steuerwerk steuert die einzelnen Schritte der Gleitkomma-
operationen.  
 
z. B. Fließ- 
punkt- 
addition: 
 
 
 

- Exponentenvergleich,  
- Exponentenangleich durch Rechts-/Linksshift  
  der Mantisse,  
- Addition der Mantissen,  
- Normalisierung 

Universität 
Osnabrück 

GTI 
4 - 57 

AG Technische 
Informatik 

4.6  Weitere wichtige Standard-Schaltnetze 
 
Code-Umsetzer 
Schaltnetze  können  allgemein  zur  Codeumsetzung  (Codie-
rung/Decodierung)  zwischen  Codes  eingesetzt  werden.  Sol-
che  Codeumsetzer  überführen  allgemein  eine  Menge  von 
Eingangswerten  auf  eine  Menge  von  Ausgangswerten.  Sie 
realisieren in der Regel eine Vektorfunktion, z. B.:  
 

 
 
 
 

- Dezimal-zu-BCD-Decoder 
- BCD-zu-Dezimal-Decoder  
- BCD-zu-7-Segment-Decoder  
- BCD-Code in Gray-Code und umgekehrt  

 
Beispiel: Decodierer (1-aus-n-Decoder) 
 

Eingänge

x0
x1
...

1nx −

DECODEn

decode(x

,

0



)x,
1-n

=

(y

,y,
1

0

y0
y1
...

Ausgänge

2ny −
1

 

y,

n

1-2

)

 

 

 

 1, 

falls 

(x

,
1-n

)X,
20



=

i

 

 

 
mit:  yi = 
 

 0,  sonst 

 
Diejenige  Ausgangsleitung  yi  wird  1,  deren  Index  i  als  Dual-
zahl am Eingang anliegt (1-aus-n-Code). Alle anderen sind 0.  
Ein 1-aus-n-Decoder wählt z.B. den aktiven Eingang in Multi-
plexern (s.u.) aus oder eine adressierte Speicherstelle. 

Universität 
Osnabrück 

GTI 
4 - 58 

AG Technische 
Informatik 

Beispiel: Codierer (Encoder) 
 
bestimmt die Bitstellennummer eines auf ´1´ gesetzten Bits.  
 

x0
x1
...

Eingänge

y0
y1
...

ENCODEn

Ausgänge

 

 

 

2nx −
1
encode(x

,x,
1

0



x,

)
n
1-2
=

=

0

(y

,y,
1
, wenn 

1ny −
)y,
1-n

xi =  
1

 
            mit:  

(y

i



)y,
20

,
1-n
Nur genau ein 
(1-aus-n Code) 

 
Voraussetzung: 
 
 
Prioritäts-Codierer:  Sind mehrere  Eingänge gleichzeitig 1, 
bestimmt der mit dem höchsten Index i 
den Ausgang. 

ix  ist 1, alle anderen 0 

 
Beispiel: 8-zu-3-Prioritäts-Encoder  
(Ausgang d unterscheidet hier zwischen den beiden Fällen x0 = 1 und 
alle Eingänge 0)  

x0  x1  x2  x3  x4 x5 x6 x7 a b c 
0  0  0  0  0  0  0  0  0  0  0 
1  0  0  0  0  0  0  0  0  0  0 
X  1  0  0  0  0  0  0  0  0  1 
X  X  1  0  0  0  0  0  0  1  0 
X  X  X  1  0  0  0  0  0  1  1 
X  X  X  X  1  0  0  0  1  0  0 
X  X  X  X  X  1  0  0  1  0  0 
X  X  X  X  X  X  1  0  1  1  0 
X  X  X  X  X  X  X  1  1  1  1 

d 
0 
1 
1 
1 
1 
1 
1 
1 
1 

Universität 
Osnabrück 

GTI 
4 - 59 

AG Technische 
Informatik 

Multiplexer (MUX) 
 
Multiplexer werden zur Auswahl von Datenquellen, also als 
Datenselektor, eingesetzt.  
 
Sie beinhalten einen Decoder für die Steuersignale, so dass 
mit n Steuereingängen eine von bis zu 2n Quellen ausgewählt 
werden kann.  

Steuerun

cn-1

c1 c0

. . .

Daten
eingäng

x 0 
x 1 
...

2n x  −
1

=

y

mux(c

−
1n

 
 

,


x,x,c,


0

0

(c

,
−
1n


)c,
20

 
Derjenige Eingang xi wird auf den Ausgang y durchgeschaltet, 
dessen  Index  i  gleich  den  Steuereingängen  interpretiert  als 
Dualzahl ist. 
 

MUXn

y 

Ausgan

 

 

=
x)

n
−
12

Universität 
Osnabrück 

GTI 
4 - 60 

AG Technische 
Informatik 

Realisierung beliebiger Schaltfunktionen mit Multiplexern 
 

c(f

−
1

n

,...,

)c,c
1
0

=

2

n
−
1
 ⋅
fm
i
=
i
0

 

i

 
Prinzip: Jeder  Eingang  xi  entspricht  einem  Minterm  mi  und 
wird genau dann auf 1 gesetzt, wenn er in der DKNF 
enthalten ist, sonst auf 0.  

  Somit  kann  mit  einem  (2n-zu-1)-Multiplexer  jede  be-
liebige  Schaltfunktion  mit  n  Variablen  realisiert  wer-
den,  indem  die  Eingänge  entsprechend  der  zu  reali-
sierenden Schaltfunktion mit 0 bzw. 1 belegt werden. 

 

 
Beispiel: Summe beim Volladdierer  
 

a

b

c

MUX3

S = f(a, b, c)

#  a  b 
c  S 
0  0  0  0  0 
1  0  0  1  1 
2  0  1  0  1 
3  0  1  1  0 
4  1  0  0  1 
5  1  0  1  0 
6  1  1  0  0 
7  1  1  1  1 

0
1
1
0
1
0
0
1

0
1
2
3
4
5
6
7

=

S

cbaf
),
,(

=
=

 
  

 

+

+
cbacbacba
+
mmmm

+
+

+

4

1

2

 

abc

 

7

Universität 
Osnabrück 

GTI 
4 - 61 

AG Technische 
Informatik 

Hinweis:  Es reicht auch ein (2n-1-zu-1)-Multiplexer für alle n-
stelligen  Schaltfunktionen,  denn  die  Adresse  und 
der zugehörige Dateneingang sind UND-verknüpft. 

 

Wird ein Steuersignal (hier a) geeignet auf die Mul-
tiplexereingänge  geschaltet,  muss  der  Multiplexer 
dann  nur  noch  halb  so  groß  sein.  Denn  jeder  Ein-
gang des Multiplexers kann für 2 Minterme  ap  und 
pa,  d.  h.  zwei  Zeilen  der  Wahrheitstafel,  genutzt 
werden.  
 
Er kann also mit  a , a, 0 oder 1 stets so beschaltet 
werden,  dass  sich  gerade  der  gewünschte  Funkti-
onswert f ergibt. 

 
 
 
Beispiel: Summe beim Volladdierer (vgl. oben) 
 

 
 

b 

c 

a

a 

a 

a 

0 

1 

2 

3 

MUX 2 

S=f(a, b, c) 

 

 
 
 

Universität 
Osnabrück 

GTI 
4 - 62 

AG Technische 
Informatik 

plexer a

als Inte

egrierte

e Scha

ltung 

Multip
 
Der TT
8-zu-1

TL-Bau
-Multip

stein S
lexer m

N7425
mit eine

1und s
m Trist

eine Va
tate-Au

arianten
sgang 

n sind z
(s. unte

z.B.  
en).  

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 63

AG T

Technische
e 
Informatik
k 

Mehrfach-Multiplexer  
 
Multiplexer werden auch zur Auswahl von ganzen Datenvek-
toren eingesetzt und dazu mehrere 1-Bit-Mulitplexer parallel 
geschaltet, die dann von einem gemeinsamen Steuersignal, 
hier c, gesteuert werden.  
 

   

 

 

 
Für parallele Multiplexer (z.B. bei Bitvektoren) reicht ein einzi-
ger 1-aus-n-Decoder für die Dekodierung der n Steuersignale 
für alle Bitstellen.  
 
Anstatt für jedes Daten-Bit einen Multiplexer zu malen, wird 
ein Multiplexer auch für die ganzen Bitvektoren gezeichnet.  

Universität 
Osnabrück 

GTI 
4 - 64 

AG Technische 
Informatik 

Demultiplexer (DEMUX) 
 
Demultiplexer dienen der selektiven Verteilung von Daten-
strömen an alternative Datensenken.  
 
Mit n Steuereingängen kann eine Datenquelle (hier x) auf bis 
zu 2n Ausgänge (y0, …, y2n-1) geschaltet werden.  

 

Steuerung

cn-1

c1 c0

. . .

Daten-
eingang

x

DEMUXn

 
 

demux(x,

c

 
 
mit:  yi = 

y0
y1
...

Ausgänge

2ny −
1

 

,

−
1n



)c,
0

= 
(y

,

0

y,

)

 

n −

1

2

 x,   falls 

i

=

c(

,
−
1n

)c,
20

 

 

 0,   sonst (neutrales Element) 

 
 
Eingang x wird also auf denjenigen Ausgang yi durchgeschal-
tet,  dessen  Index  i  gleich  den  Steuereingängen  interpretiert 
als Dualzahl ist. Die übrigen Ausgänge yi sind Null. 

Universität 
Osnabrück 

GTI 
4 - 65 

AG Technische 
Informatik 

Komparatoren für (pos.) Dualzahlen  
 
4-Bit Komparator (Vergleicher) 
 

b3

a3

b2

a2

b1

a1

b0

a0

Komparator

yA<B

yA=B

yA>B

 

=

(y

y,

=

BA

y,

>

BA

)

 

<

BA

 
 

komp(a

,

1N-



,b,a,
1N-

0

)b,
0



 
 
mit:  yA<B = 1  falls (aN-1, ... , a0)2  < (bN-1, ... , b0)2, sonst 0 
yA=B = 1  falls (aN-1, ... , a0)2  = (bN-1, ... , b0)2, sonst 0 
 
yA>B = 1  falls (aN-1, ... , a0)2  > (bN-1, ... , b0)2, sonst 0 
 
 
 
Realisierung durch Subtrahierer oder direkt als Schaltnetz 
möglich 
 
Bei einer Realisierung als zweistufiges Schaltnetz wird bei 
größeren Wortbreiten der Realisierungsaufwand recht groß. 
Deswegen wird der Vergleicher kaskadiert, also der Vergleich 
stufenweise durchgeführt und die Ergebnisse zusammenge-
fasst.  
 

→ mehrstufige Logik 

Universität 
Osnabrück 

GTI 
4 - 66 

AG Technische 
Informatik 

Realis
 
Ein kas
SN748

sierung
skadier
85.  

g als TT
rbarer 4

TL-IC 
4-Bit-Ko

omparaator in TTTL-Te

echnik i

st der 

 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 67

 

AG T

Technische
e 
Informatik
k 

Paritätsgenerator/-prüfer zur Fehlererkennung 
 
Paritätsgenerator für gerade Parität (even parity): 
 

 
x 0 
x 1 

= 1 

“Parity Tree“ 

= 1 

= 1 

x 2 
x 3 
P 

P = x 0

 ⊕  x 1  ...  ⊕  x n-1
 

 
Paritätsbit P ergänzt n Datenbits x0, x1 ... xn-1 so um ein weite-
res Bit, dass immer eine gerade Anzahl von Einsen entsteht. 
 
  Einfach-Fehler im gesamten Bitvektor x0, x1, ... xn-1, P (inkl. 

Paritätsbit) durch Paritätsprüfung erkennbar. 

 
Paritätsprüfer für gerade Parität 
 

 
x 0 
x 1 

x 2 
x 3 
P 

Paritätsgenerator 

= 1 

= 1 

= 1 

E = P  ⊕  (x 0

 ⊕  x 1 

  ...  ⊕  x n-1)

= 1 

E = 

0: No Error 

1: Parity Error 

 

 
 

Ungerade Parität:  analog mit Ergänzung auf ungerade Anzahl 

von Einsen (odd parity). 

Universität 
Osnabrück 

GTI 
4 - 68 

AG Technische 
Informatik 

Datentransport, Busse  
 
Für den Transport von Daten über Multiplexer und Demulti-
plexer werden meist größere Gatter und damit viele Leitungen 
und Chipfläche benötigt. Gerade in Mikroprozessoren und 
anderen Rechenschaltungen werden deshalb meist so ge-
nannte Busse eingesetzt, um Daten zu verteilen.  
 
Bei Bussen werden Leitungsbündel im Zeitmultiplex für die 
Übertragung von alternativen Datenquellen genutzt. D.h., es 
wird immer nur 1 Datenquelle nach einander ausgewählt, die 
auf den Datenbus schreiben darf. Es können aber beliebig 
viele Datensenken lesend auf den Datenbus zugreifen.  

Dafür werden an den Ausgängen der Datenquellen Tristate-
Treiber (Three-State-) eingesetzt. D.h., mit einem Steuersig-
nal („Enable“) wird der Ausgang aktiv bzw. inaktiv (passiv, 
hochohmig) geschaltet. Nur im aktiven Zustand hat der Trei-
ber die Möglichkeit, den Leitungszustand auf ´0´ oder ´1´ zu 
setzen.  

 

         

 

 
Der inaktive, hochohmige Zustand wird in den logischen Glei-
chungen bzw. Funktionstabellen meist mit ´Z´ gekennzeich-
net.  
 
Mit solchen Tristate-Treibern lassen sich dann ganz elegant 
De-/Multiplexerfunktionalitäten über Busse realisieren. Vo-
raussetzung ist, dass immer genau ein Treiber pro Leitung 
bzw. ein Satz von Treibern pro Bus aktiviert wird.  

Universität 
Osnabrück 

GTI 
4 - 69 

AG Technische 
Informatik 

ktiona

le Bus

se  

Bidire
 
Gerade
Periph
häufig 
den bid
/Recie

e an de
herie so
in beid
direktio
ver) ge

en Schn
owie inn
de Rich
onale Tr
enannt, 

nittstell
nerhalb 
tungen
reiber, 
bzw. b

en von
 der Sc
n ausge
auch T
bidirekti
c

 Mikrop
chaltung
etausch
Transce
onale B

prozess
gen mü
t werde
eiver (T
Busse v

soren u
üssen S
en. Daz
ransmi
verwen

und ihre
er 
Signale
 
zu wer-
tter 
det.  

x

y

 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 70

AG T

Technische
e 
Informatik
k 

 

4.7  Laufzeiteffekte in Schaltnetzen 
 
Glitches und Hazards 
 
Neben dem funktionalen Verhalten ist das zeitliche, also das 
dynamische bzw. transiente Verhalten der Verknüpfungsglie-
der  wesentlich  für  das  korrekte  Verhalten  eines  Systems. 
Denn  die  Ausbreitung  elektrische  Signale  auf  Leitungen  und 
das  Durchlaufen  von  Schaltgliedern  benötigen  Zeit,  die  
(Signal-)Laufzeit.  
 
Die  Laufzeiten  hängen  von  vielen  Parametern  ab,  z.B.  von 
der Länge einer Leitung und von der Art und dem Fan Out ei-
nes Schaltgliedes.  
 
Kritisch wird es, wenn Signale sich über verschiedene Wege 
innerhalb  einer  Schaltung  ausbreiten  und  wieder  verknüpft 
werden. Das Betrachten des stationären Verhaltens ist dann 
nicht  immer  ausreichend.  Denn  Unterschiede  in  den  Signal-
laufzeiten  können  (müssen  aber  nicht  immer)  bei  mehrstufi-
gen  Logikschaltungen  zu  kurzen,  transienten  Störimpulsen 
führen.  Um  solche  Effekte  aufzudecken,  muss  das  dynami-
sche Verhalten analysiert werden.  
 
Def.: Ein  Glitch  ist  eine  kurze  Signaländerung,  die  bei  stati-
scher  Betrachtung  der  Schaltvariablen  theoretisch  oder 
bei  idealen  Verknüpfungsgliedern  nie  auftreten  würde 
(dürfte).  

 
Def.: Man spricht von einem Hazard (engl.: Zufall, Gefahr, Ri-
siko),  wenn  in  einer  Schaltung  die  Möglichkeit  besteht, 
dass Glitches auftreten.  

 
Hazards  sind  also  nur  potentiell  fehlerhafte  Schaltzustände, 
die an Signalübergängen möglich sind.  

Universität 
Osnabrück 

GTI 
4 - 71 

AG Technische 
Informatik 

Beispie

el:  

 
Man s
rung v
tiell au
Änderu
aber  e
Laufze
 
Entste
 

 

pricht v
on Eing
ufgrund 
ung  de
eigentlic
eitverzö

von sta
gangss
 von La
er  Einga
ch  kons
ögerung

atischen
signalko
aufzeite
angssig
stant  0
g statisc

n 1(0)-H
ombina
en kurz
gnale  a
0(1)  lief
ch verh

Hazard
tionen 
ze 1(0)-
auftrete
fern  mü
halten w

s, wen
gibt, be
-Störim
n  könn
üsste,  d
würde.  

nn es e
ei dene
mpulse 
nen,  da
d.  h.  si

a-
ine Pa
n-
en pote
bei eine
er 
nal 
as  Sign
ich  ohn
ne 

hung v

von (sta

atischen

n) Haza

ards (Pr

rinzip) 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 72

 

AG T

Technische
e 
Informatik
k 

(

a
1

−−
11

⋅=
ee

Analyse der Entstehung von (statischen) Hazards 
 
Werden die Laufzeiten berücksichtigt, können Hazards in den 
Schaltfunktionen  dadurch  identifiziert  werden,  dass  in  den 
Verknüpfungen Unterschiede bei den Laufzeitindizes (hier als 
Exponent angegeben) auftreten.  
 
Beispiel: Hazards bei obigen Schaltungen  
 
 
 
 
 
 
 
 
 
 

   0-Hazard  

   1-Hazard  

   0-Hazard  

 1-Hazard  

−
1

=


−
1

=


+=
ee

 +
e



−−
11





(

=

e

=

e

+

e

+

e

−

2

⋅

e

−
1

⋅

e

−
1

e

=

a

4

−
1

e

−
1

e

=

a

2

−
1

⋅

e

−

2

 

−
1

−

2

)

)

e

−

2

a
3

Universität 
Osnabrück 

GTI 
4 - 73 

AG Technische 
Informatik 

In  KV-Diagrammen  sind  Hazards  daran  zu  erkennen,  dass 
zwei  Vereinfachungsschleifen  von  Primimplikanten  aneinan-
der stoßen, sich aber nicht überlappen.  
 

a, b a

0

c

0
1

1
1

0

1
1
1 1
b

b

f(a,

c)b,

+

bc

ca

 

 
=

c a

 

 
Ein Hazard (und damit auch ein Glitch) wird durch das Hinzu-
fügen eines redundanten Terms, d.h. eines zusätzlichen Gat-
ters, vermieden, der diesen Übergang abdeckt.  
 
Dieser  ist  z.  B.  im  KV-Diagramm  recht  einfach  durch  eine 
Vereinfachungsschleife  über  diesen  Wechsel  hinweg  zu  be-
stimmen.  

0

c 

0 
1 

a, b a

11 1
1
1
1 1
b

0

b

c a

ab

 

f(a,

c)b,

 
ab

=

+

+

bc

ca

 

Universität 
Osnabrück 

GTI 
4 - 74 

AG Technische 
Informatik 

Hazard

ds 

gen  Sc
dynami
nterschi
beeinflu

gen  kö
chaltung
Hazard
ische  H
iedliche
en  Lau
 
ussen. 

önnen  n
s  entst
fzeitver

neben 
tehen, 
rzögeru

statisc
wenn 
ungen 

chen  H
mehre
ein  Au

a-
re 
s-

ische H
Signalüb
gnal nu

Hazard
bergän
ur einen

ds sind
ge) an 
n Signa

 potent
Stellen
alwechs

tielle M
n, bei d
sel vorn

Mehrfac
denen 
nehmen

htransi
ein Au
n sollte

ti-
s-
.  

mische 

hrstufig
auch  d
mit  un
signal b

Dynam
 
In  meh
zards 
Wege 
gangss
 
Def.: D
Dynami
o
onen (S
g
gangssi

 
Sie kö
bei ein
nal  zw
Hazard
 
Die  Ur
Verzög
 
Beispie

el: 

önnen s
ner Änd
war  zun
ds vorü

sich als
derung 
nächst 
übergeh

s zusätz
eines 
richtig 
hend w

zliche S
Eingan
veränd
ieder a

Signalw
ngssign
dert  wir
uf den 

wechse
nals das
rd,  abe
alten W

l äußer
s Ausg
er  durch
Wert zu

rn, wen
nn 
g-
angssi
h  intern
ne 
lt.  
rückfäl

rsache 
gerunge

sind  m
en, übe

mehrere
er die e

e  Logik
ein Sign

kpfade 
nalwech

mit  un
hsel wir

nterschi
rksam i

iedliche
st.  

en 

 

Universitä
ät 
ck 
Osnabrüc

 

GTI
4
4 - 75

AG T

Technische
e 
Informatik
k 

In der Praxis ist die Hazard-Problematik oft noch komplexer, 
weil sich die Laufzeiten von Schaltgliedern abhängig von de-
ren Betriebsbedingungen (z.B. Temperatur und Spannung) im 
Betrieb  ändern  können  und  dadurch  nicht  in  jedem  Fall  Ha-
zards zu Glitches führen.  
 
 
Echte  Glitches  können  sich  insbesondere  bei  Schaltwerken 
(Automaten; s. Kap. 6) kritisch auswirken, weil hier fehlerhafte 
Übergangszustände  ggf.  zu  dauerhaften  Zustandsänderun-
gen  und  damit  zu  einem  Fehlverhalten  des  ganzen  Schalt-
werkes führen können.  
 
Die  Eliminierung  von  Hazards  und  Glitches  kann  durch  re-
dundante  Gatter  oder  Extraverzögerungen  erfolgen,  ist  aber 
oft nur eingeschränkt möglich.  
 
Lösung: getaktete Verarbeitung, d.h. Trennung von 
 

 
- Signalverarbeitung in Schaltnetzen 
  (incl. aller transienten, laufzeitbedingten Effekte)  

 
 
 

 
      

 

Universität 
Osnabrück 

und  

- Übernahme der Ergebnisse nach dem Einschwin- 
  gen als fester, stationärer  Ausgangspunkt für den 
  nächsten Verarbeitungsschritt  

Zwischenspeichern von zu verknüpfenden Signa-
len nötig (s. Kap. 5), damit sie während ihrer Ver-
arbeitung stabil sind,  
und entsprechend verzögerte Übernahme der Ver-
knüpfungsergebnisse in der stationären Phase 

GTI 
4 - 76 

AG Technische 
Informatik 

Sch
inte

haltne
egrier

tz-Im
rten S

mplem
chaltu

rung m
entier
ungen
n 

mit  

Kla

assen i

integr

rierte

r Sch

altung

gen  

ationss
Smal
Mediu
Large
Grand
  Very 

stufen 
l Scale
um Sca
e Scale 
d Scale
Large S

 Integra
ale Integ
Integra
e Integra
Scale In

ation
gration 
 
ation 
ation 
ntegrati

(< 1
(102
(103
(104
on (> 1

02 Tran
2 < Tran
3 < Tran
4 < Tran
05 Tran

nsistore
ns. < 10
ns. < 10
ns. < 10
ns.) 

en) 
03) 
04) 
05) 

4.8 

 
4.8.1 
 
Integra
SSI 
MSI 
LSI 
GSI 
VLSI

 
 
 
 
Typolo
 

ogie in

ntegrier

rter Sc

haltun

gen 

 

Universitä
ät 
ck 
Osnabrüc

 

GTI
4
4 - 77

AG T

Technische
e 
Informatik
k 

 

Stand
-  Entw
fest 
drah
-  (ein
geg

dardsc
wickler 
vorgeg
htet sie
mal  od
ebener

chaltun
sucht 
gebene
e fest m
der  me
r Mächt

ngen
sich  a
er  Baus
iteinan
ehrmals
tigkeit

aus  ein
steine  d
der. 
s)  prog

nem  S
die  pas

pektrum
ssende

m  ange
n  aus 

eboten
und  ve

er 
er-

rammie

erbare 

Bauste

eine  vo

or-

vorgege
sch alle
driger b

ebene 
e digital
is mittle

Schalt
e Grun
erer Int

tbauste
ndgatte
tegratio

eine 
r und G
onsdicht

Grundsc
te verfü

chaltun
ügbar. 

gen sin

nd 

el: TTL

-Bauste

einfam

ilie 

 
Fest v
 
Praktis
in nied
 
Beispie

 

 

4-
-fach N

AND-G

Gatter 7

 
7400 

8-fach
h D-Lat
ät 
Universitä
ck 
Osnabrüc

 

e und T
GTI
4
4 - 78

tch mit 

Enable

ristate-

-Ausgän

 
ngen 7
AG T

4LS373
3 
Technische
e 
Informatik
k 

Anwe
 
PROM

 

enderp

progra

mmier

rbare 

Schal

tunge

en 

M (Progr

ramma

ble Rea

ad Only

y Memo

ory) 

 

Matrix  e
ssdecod
vektore

enthält 
der).  Fr
en in de

alle  M
rei  prog
er ODE

Minterm
gramm
R-Matr

e,  die  f
ierbare
rix.  

fest  de
e  Zuord

ekodiert
dnung  d

t  werde
en 
s-
der  Au

eltechn

nik:  Si
gr

cherun
ammie

g  (Fus
rung be

se)  vor
ei einem

r  und 
m PRO

nach  d
OM (vera

der  Pro
o-
altet) 

 
UND-M
(Adres
gangsv
 
Beispie

 

 

Unprogr

rammed 

Fuse 

Programm

med Fus

e 

 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 79

AG T

Technische
e 
Informatik
k 

Program

mmable

e Logic 

c Device
e) 

OM  mit 
x oder b

anwen
nderpro
. 
beidem

ogramm

mierbare

rer  UND

D-Matri

ix, 

PLD (P
 
Ähnlich
ODER
 
Darste

h  PRO
R-Matrix
ellung: 

 

 

 
Beispie

el:  PAL
bar

L (Prog
rer UND

gramma
D-Matrix

able Ar
x und fe

rray Lo
fester O

ogic) mi
ODER-M

it progr
Matrix 

rammie

er-

 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 80

 

AG T

Technische
e 
Informatik
k 

nten pr

rogram

mmierba

arer Lo

ogikbau

usteine
e  

Varian
 
- (P)RO
- PAL 
- PLA 

OM ((P
(Progra
(Progra

Program
ammab
ammab

mmable
ble Arra
ble Logi

 Only M
) Read
ay Logic
c)  
y) 
ic Array

Memory
y) 

    = fest
 
X = prog

te Verknüpf
g.bare Verk

fung 
knüpfung 

Universitä
ät 
ck 
Osnabrüc

GTI
4
4 - 81

AG T

Technische
e 
Informatik
k 

 

Anwenderspezifische Schaltungen  
 
ASICs = Application Specific Integrated Circuits 
Der  Entwickler  trägt  einen  Teil  oder  alles  zur  anwendungs-
spezifischen Entwicklung der integrierten Schaltung bei. 
-  Gate  Arrays:  IC-Hersteller  fertigt  Gatterstruktur  vor,  der 

Entwickler legt dann nur noch Verbindungsstruktur fest. 

-  Standardzellen:  IC-Hersteller  gibt  Bibliothek  von  vordefi-
nierten  Zellen  vor,  die  der  Entwickler  mittels  CAD-System 
zum speziellen Entwurf zum Maskenlayout kombiniert. 

-  voll  anwenderspezifisch:  Anwendungsentwickler  entwirft 

vollständig neue integrierte Schaltung. 

 

 
 
FPGAs = Field Porgrammable Gate Arrays 
 
Integrierte  Bausteine  vorgegebener  Mächtigkeit  mit  einer 
Vielzahl programmierbarer, niedrig bis mittel komplexer Logi-
kelemente,  die  anwendungsspezifisch  konfiguriert  und  ver-
schaltet werden.  
 
    Der Entwickler beschreibt den Entwurf auf einer abstrak-

teren Entwurfsebene (s. unten).  

Automatisiert arbeitende Entwurfswerkzeuge generieren 
daraus  Konfigurationsdateien,  die  auf  die  FPGAs  gela-
den  werden  und  diese  dann  anwendungsspezifisch 
(persistent oder flüchtig) programmieren.  

 
 

Universität 
Osnabrück 

GTI 
4 - 82 

AG Technische 
Informatik 

4.8.2  Entwurfsablauf einfacher integrierter 

Schaltungen  

 
Entwurfsablauf bei  einfachen Schaltnetzen 
 
 

(1) Aufstellen der Wahrheitstafel oder schaltalgebraischen 

Gleichungen 

(2) Ableitung der DKNF (bzw. KKNF) 
(3) Minimierung z.B. mittels KV-Diagramm oder Quine-

McCluskey 

(4) Zeichnen des Schaltbildes. Gängige Varianten: 

(a) Zweistufige UND/ODER- (bzw. ODER/UND-) Reali-

sierung 

(b) Zweistufige NAND- (bzw. NOR-) Realisierung 
(c) Transformation in mehrstufige UND/ODER- (bzw. 

ODER/UND-) Realisierungen 

(d) Transformation in mehrstufige NAND- (bzw. NOR-) 

Realisierungen 

oder Transformation in programmierbare Logik  

(5) Simulation und Test 
(6) Realisierung der Schaltung durch Festverdrahtung oder 

Programmierung/Konfiguration   

Universität 
Osnabrück 

GTI 
4 - 83 

AG Technische 
Informatik 

Transformation (Schritt 4) 
 
In der Regel zweistufige Realisierung 
 
Ausgangspunkt:  Zweistufige  UND/ODER-Realisierung  der 

DMF 

 
 

. . . 

& 

x i 

. . . 

. . . 

. . . 

& 

xi

. . .

. . .

. . .

&

. . .

&

≥ 1 

UND/ODER 

&

NAND

   

 

 
 
UND- bzw. ODER-Gatter durch NAND-Gatter ersetzen, Struk-
tur bleibt erhalten.  
 
Achtung:  Einzelne (direkte) Leitungen in das ODER-Gatter 
müssen invertiert werden (analog zu einem zum 
Inverter degenerierten NAND-Gatter). 

 
ODER/UND  NOR:  Ersetzen durch NOR-Gatter,  

sonst ganz analog 

 
Fazit: 

Um eine minimierte NAND-Realisierung zu erhal-
ten,  geht  man  von  der  DMF  aus,  für  einen  mini-
mierte NOR-Realisierung von der KMF. 

Universität 
Osnabrück 

GTI 
4 - 84 

AG Technische 
Informatik 

Mehrstufige Realisierung 
 
Die meisten Technologien lassen nur eine begrenzte Zahl von 
Eingängen je Gatter (Fan-In) und Anschlüssen nachgeschal-
tete Gatter an den Ausgängen (Fan-Out) zu. 
 

Fan-In

(typ. 2..8)

... &

...

&

&

Fan-Out
(typ. 2..10)

 

 
„Breitere“ Gatter in einer zweistufigen Realisierungen müssen 
daher  in  mehrstufige  Realisierungen  zu  „schmalen“  Bäumen 
aus Gattern transformiert werden. 

x0

. . .
&

xn-1

x0

x1

x2

x3

xn-4

xn-3

xn-2 xn-1

&

&

. . .

&

&

&

&

AND-Tree

. . .

. . .

&

 
 
 
 
 
 
 
 
 

x0x1x2x3...xn-4xn-3xn-2xn-1 = (((x0x1)(x2x3))…((xn-4xn-3)(xn-2xn-1))) 

 
Nutzung des Assoziativgesetzes möglich  
 
ODER-Gatter ganz analog (OR-Tree) 
 
Funktioniert aber nicht bei NAND- bzw. NOR-Gattern, da nicht 
assoziativ!         anderer Weg nötig  

Universität 
Osnabrück 

GTI 
4 - 85 

AG Technische 
Informatik 

Transformation  mehrstufiger  UND-ODER-Verknüpfungen 
in mehrstufige NAND-Verknüpfungen  
 
Vorgehen: 
 
(1)  Konvertiere alle UND-Gatter und alle ODER-Gatter in NAND-
Gatter  (Anfügen  von  Negations-Blasen  am  Ausgang  von 
UND- bzw. den Eingängen von ODER-Gattern). 

(2)  Treibt  ein  negierter  Ausgang  einen  negierten  Eingang,  sind 

keine weiteren Schritte erforderlich. 

(3)  Treibt  ein  negierter  Ausgang  einen  nicht  negierten  Eingang 

oder umgekehrt, muss ein Inverter eingeführt werden. 

(4)  Treibt eine Eingangsvariable einen invertierten Eingang, muss 

sie invertiert werden. 
 
a 
b 

& 

& 

c 

≥ 1 

d 

≥ 1 

f 

e 

a 
b 

Inverter einfügen  Negationen 
heben sich auf 
& 
≥ 1 

& 

c 

d 
Invertieren 

Inverter einfügen 

e 

≥ 1 

≥ 1 

f 

= 

& 

a 
b 

& 

& 

c 

& 

& 

& 

d 

& 

f 

e 

Universität 
Osnabrück 

GTI 
4 - 86 

1 

= 

& 

 

AG Technische 
Informatik 

Alternative: Transformation  von  zweistufig  UND-ODER  nach 
mehrstufig UND/ODER alternierend mit ODER am 
Ende (Ausklammern der DMF).  

 
 

Dann können direkt die UND- und ODER-Gatter in 
NAND-Gatter verwandelt werden (vgl. mehrstufige 
Transformation) 

 
Transformationen  von  ODER/UND-Verknüpfungen  in  NOR-
Verknüpfungen erfolgen ganz analog (Dualitätsprinzip) 
 
 
 
 
Weitere Realisierungsmöglichkeiten von Schaltnetzen: 
-  Decoder (mit Zusatzgattern) etc. 
-  Multiplexer 
-  Programmierbare Logik (PLDs oder FPGAs) 

Universität 
Osnabrück 

GTI 
4 - 87 

AG Technische 
Informatik 

