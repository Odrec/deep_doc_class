Informatik C

Grundlagen der Technischen Informatik

Prof. Dr.-Ing. Werner Brockmann, M. Sc. Jonas Schneider
¨Ubung 12 - Stoppuhr auf dem ATmega16
Abgabe bis Di, 27.01.2015, 14:00 Uhr in der Vorlesung

Hinweis: Schicken Sie, zus¨atzlich zu Ihrer schriftlichen Abgabe, bitte Ihre Assemblerpro-
gramme per Mail an Ihren Tutor, damit diese auch getestet und im Testat vorgef¨uhrt werden
k¨onnen.

Assembler-Coding-Style

Da wir uns nun mit realen Prozessoren besch¨aftigen und diese mehr M¨oglichkeiten bie-
ten, durch Strukturierungen oder Namensvergaben lesbaren Code zu schreiben, ist folgender
Coding-Style einzuhalten:

• F¨ur verwendete Register sind sinnvolle Namen zu benutzen.
• Variablennamen und Registernamen sind selbsterkl¨arend und werden klein geschrieben

und bei Bedarf durch Unterstriche getrennt, z.B. segment nr, timer5, clock time.
• S¨amtliche Initialisierungen stehen einheitlich am Anfang einer Programmeinheit.
• Unterprogrammnamen, Makronamen und Konstanten werden GROSS geschrieben (und

ggf. durch Unterstriche getrennt), z.B. LOAD PATTERN, WAIT 5 MS.

• Sprungziele innerhalb von Makros, Unterprogrammen oder dem Hauptptogramm wer-
den dagegen nur am Anfang groß geschrieben (und durch Unterstriche getrennt), z.B.
Load Pattern 1:, End of UP:.

• Die ¨Ubersichtlichkeit wird durch Einr¨uckungen unterst¨utzt.
• Ausf¨uhrliche Dokumentation aller Programmteile: Zu Beginn von Unterprogrammen
und Makros werden Ein- und Ausgabeparameter mit deren Zweck und Datentyp (und
ggf. dem zul¨assigen Wertebereich), sowie eine kurze Funktionsbeschreibung (’Was’ soll
das UP machen bzw. ’Wie’ arbeitet der Algorithmus) als Kommentar angegeben. Details
der implementierten Funktionen werden dann im Coderumpf kommentiert.

• Bei Unterprogrammen und Makros ist grunds¨atzlich auf Seiteneﬀektfreiheit zu achten.
• Falls nicht anders angegeben, endet das Programm in einer Endlosschleife.

Hinweise zur Assemblerprogrammierung auf dem ATmega16

• Schreiben Sie vollst¨andige Programme, die an Adresse 0 (Reset-Interrupt) starten. D.h.
beachten Sie, dass Sie vor der Verwendung des Stacks den Stackpointer initialisieren
m¨ussen. Ebenso m¨ussen alle Register vor Ihrer Verwendung initialisiert werden. Ihre
Programme m¨ussen ausf¨uhrbar und simulierbar sein.

• Benutzen Sie zur einfacheren Programmﬂusskontrolle die Branch-Anweisungen, die auf

die verschiedenenen Flags des ATmega16 pr¨ufen.

• Verwenden Sie f¨ur einfache Abfragen die einfachen Skip-Befehle statt der komplexeren

Branch-Befehle.

1

Einfache Stoppuhr

Im Folgenden soll mit dem ATmega16 eine einfache 1-Minuten-Stoppuhr umgesetzt werden.
Diese erh¨alt ¨uber den Pin PD2 ein Taktsignal mit einer Frequenz von 1 Hz. Die Stoppuhr
verwaltet in einem Register den aktuellen Z¨ahlerstand in Form gepackter BCD-Zahlen f¨ur die
10er und 1-er Sekundenstellen. Das bedeutet, dass die Zehnerstelle im High-Nibble und die
1er-Stelle im Low-Nibble des Registers abgelegt werden.
¨Uber zwei weitere Pins wird die Stoppuhr gesteuert. Ein positives Signal an Pin PA0 soll die
Stoppuhr auf 0 Sekunden asynchron zur¨ucksetzen. Ein positives Signal an Pin PA1 pausiert
die Stoppuhr, w¨ahrend ein negatives Signal die Stoppuhr laufen l¨asst.
Die Ausgabe des Stoppuhrstandes erfolgt fortlaufend ¨uber eine zweistellige 7-Segment-Anzeige.
Der Z¨ahlerstand soll von 59 Sekunden wieder auf 0 Sekunden ¨uberlaufen und den ¨Uberlauf
an Pin PA2 durch einen 1-Puls von 1 Sekunde signalisieren. Neben diesem Signal gibt die
Stoppuhr ¨uber Pin PA3 ein Alive-Signal aus, das zyklisch wechselt und so anzeigt, dass das
Programm auf dem ATmega16 noch korrekt arbeitet.
Die Zeit soll zun¨achst mit Hilfe des externen Taktsignals an Pin PD2 gez¨ahlt werden. Paral-
lel dazu wird die 10er und 1er Stelle st¨andig 7-Segment-codiert ausgegeben. Die 10er-Stelle
wird dazu an Port B und die 1er-Stelle an Port C ausgegeben. Die BCD-codierten Zahlen
m¨ussen somit in die entsprechenden 7-Segment-Codes umgewandelt werden. Diese sind in
einer Tabelle im Datenspeicher abgelegt.
Hinweis: Die Aufgaben dieses ¨Ubungsblattes bauen teilweise aufeinander auf, lassen sich
jedoch auch separat l¨osen (unter der Annahme, dass entsprechende Unterprogramme oder
Makros aus vorhergehenden Aufgabenteilen vorliegen.

Aufgabe 12.1:

Systemstruktur

(6 + 4 = 10 P)

a) Zeichnen Sie ein Modulbild der auf dem ATmega16 realisierten Stoppuhr. Machen Sie in
dem Modulbild kenntlich, welche Funktionalit¨at ¨uber welchen Port nach außen gef¨uhrt
ist.

b) Stellen Sie einen Registerbelegungsplan auf, der festh¨alt, welche Register f¨ur welche

Aufgaben verwendet werden.

Aufgabe 12.2:

Konﬁguration der I/O-Ports

(10 P)

Zun¨achst sollen die Ein- und Ausgabeports f¨ur das Programm konﬁguriert werden. Schreiben
Sie hierzu ein seiteneﬀektfreies Unterprogramm INIT PORTS, in dem Pin PA0 und PA1 an
Port A als Eingang mit internem Pull-Up und Pin PA2 sowie PA3 als Ausgang konﬁguriert
werden, ohne die restliche Konﬁguration des Ports zu ver¨andern. Port B und Port C sollen
vollst¨andig als Ausgang konﬁguriert werden. Konﬁgurieren Sie zus¨atzlich Pin PD2 als Eingang
ohne internen Pull-Up, ohne die restliche Konﬁguration des Ports zu ver¨andern.

Aufgabe 12.3:

Ausgabe der 7-Segment-Codes

(10 P)

Nun soll ein seiteneﬀektfreies Unterprogramm SSEG OUT geschrieben werden, das den ge-
genw¨artigen Z¨ahlerstand der Stoppuhr durch eine im Speicher abgelegte Lookup-Table in
zwei 7-Segment-Codes ¨uberf¨uhrt und diese auf den Ports B und C ausgibt. Legen Sie dazu
die Lookup-Table im Datenspeicher des ATmega16 ab und greifen Sie mit Hilfe eines der
Indexregister geschickt auf die Tabelle zu. Starten Sie die Tabelle an ihrer Basisadresse mit
dem Bitmuster f¨ur die Ausgabe der 0 und legen Sie die weiteren Ziﬀern aufsteigend dahinter
ab. Geben Sie die Ansteuerungen der Segmente auf den Pins 0 bis 6 der Ports aus, wobei Pin
0 dem Segment a und Pin 6 dem Segment g entspricht. F¨ur eine Auﬂistung der verschiedenen
7-Segment-Muster k¨onnen Sie Aufgabe 5 auf dem 3. Aufgabenblatt heranziehen.

2

Aufgabe 12.4:

Hauptprogramm

(10 P)

Schreiben Sie das Hauptprogramm, das zun¨achst den Stackpointer initialisiert, die Ports
initialisiert, die Stoppuhr mit 00 initialisiert und dann in einer Endlosschleife den aktuellen
Z¨ahlerstand an Port B und Port C 7-Segment-codiert ausgibt. Außerdem soll hier der Pin
PA0 abgefragt und ggf. die Stoppuhr zur¨uckgesetzt werden.

Aufgabe 12.5:

Polling vs. Interrupt

(4 + 10 + 4 + 6 + 4 = 28 P)

Der Takt an Pin PD2 liefert im Sekundenabstand positive Flanken. Zur Erkennung der posi-
tiven Flanke werden hier die Mechanismen von Polling und Interruptsteuerung verglichen.

a) Erweitern Sie das Hauptprogramm aus Aufgabenteil 12.3 um die Abfrage des Pins PD2
per Polling in jedem Durchlauf der Endlosschleife. Bei einer steigenden Flanke an diesem
Pin soll, sofern kein Pause-Signal an Pin PA1 anliegt, ein Unterprogramm COUNT UP
aufgerufen werden, das die Stoppuhr um eine Sekunde weiterz¨ahlt.

b) Schreiben Sie nun das Unterprogramm COUNT UP, das die Stoppuhr um eine Sekunde
weiterz¨ahlt. Die Z¨ahlerst¨ande sollen als gepackte BCD-Zahlen (Einer- und Zehnerstelle
auf dem Low- bzw. High-Nibble) in dem Z¨ahlregister abgelegt sein.

c) Der ATmega16 l¨asst sich auch so konﬁgurieren, dass eine steigende Flanke an Pin PD2
einen Interrupt (INT0) ausl¨ost. Schreiben Sie eine Interrupt-Serviceroutine ISR CLOCK,
die bei einem Interrupt abh¨angig vom Pause-Signal an Pin PA2 das Unterprogramms
COUNT UP aufruft.

Hinweis: Die f¨ur das Aufsetzen dieses externen Interrupts notwendigen Schritte k¨onnen
Sie aus den Hilfsmaterialien zu diesem ¨Ubungszettel entnehmen. Auf den ersten drei
Seiten ﬁnden Sie dort einen entsprechenden Auszug aus dem Datenblatt des ATmega16.

d) Schreiben Sie das Unterprogramm INIT EXT INTERRUPT zur Interruptkonﬁguration, so
dass eine steigende Flanke an Pin PD2 die Interrupt-Serviceroutine aus Aufgabenteil
c) aufruft, und f¨ugen Sie die ben¨otigte Interrupt-Vektortabelle an der entsprechenden
Stelle im Code ein. Das Hauptprogramm ben¨otigt nun das Polling nicht mehr sondern
k¨ummert sich nur um die Ausgabe und das R¨ucksetzen der Z¨ahlerst¨ande. Kennzeichnen
Sie alle erforderlichen ¨Anderungen im Hauptprogramm.

e) Welche Vorteile bietet die Realisierung durch einen Interrupt gegen¨uber der Polling-

Variante?

Aufgabe 12.6:

T/C0-Interrupt

(6 + 14 = 20 P)

Um den externen 1 Hz Taktgeber einzusparen, soll der 1 Hz Takt in dieser Aufgabe intern er-
zeugt werden. Dazu wird der ATmega16 mit einem Uhrenquarz betrieben. Ein solcher Quartz
schwingt mit einer Frequenz von 215 = 32.768 Hz. Um den zum Hochz¨ahlen der Stoppuhr
notwendigen Sekundentakt abzuleiten, soll die Timer-Counter-0-Hardware (T/C0-Hardware)
des ATmega16 genutzt werden. Diese arbeitet mit einem 8-bit Z¨ahlregister und kann so konﬁ-
guriert werden, dass sie in regelm¨aßigen Zeitabst¨anden einen internen Interrupt ausl¨ost, ¨uber
den die Stoppuhr hochgez¨ahlt wird.

a) Welcher Prescale-Faktor wird ben¨otigt, um mit Hilfe des 8-Bit-Z¨ahlers TCNT1A bei ei-
nem Prozessortakt von 32.768 Hz eine Zyklusdauer von exakt einer Sekunde hervorzuru-
fen? Welche zeitliche Auﬂ¨osung resultiert aus diesem Prescale-Faktor? Geben Sie einen
Prescale-Faktor an, der beim T/C-0 eingestellt werden kann. Welchen Vergleichswert
m¨ussen Sie einstellen?

3

b) Tauschen Sie nun das Unterprogramm INIT EXT INTERRUPT gegen eine Variante namens
INIT TC0 INTERRUPT aus, die die Initialisierung der T/C0-Hardware durch Einstel-
len des entsprechenden Wertes im Output-Compare-Register und Setzen des Prescale-
Faktors aus Aufgabenteil a) in den entsprechenden Registern durchf¨uhrt. Wird der Ver-
gleichswert erreicht, soll ein Interrupt ausgel¨ost werden, der die Interrupt-Serviceroutine
ISR CLOCK aufruft. Konﬁgurieren Sie die dazu notwendigen Register und f¨ugen Sie die
ben¨otigte Interrupt-Vektortabelle an der entsprechenden Stelle im Code ein. Starten Sie
anschließend den mit 0 initialisierten Counter. Sind weitere ¨Anderungen am Hauptpro-
gramm n¨otig?

Hinweis: Orientieren Sie sich f¨ur die Konﬁguration des T/C-0-Interrupts am Skript
Seite 9-63ﬀ.. F¨ur weitere Details zum T/C-0 ﬁnden Sie in den Hilfsmaterialien zu diesem
Aufgabenblatt den entsprechenden Teil des Datenblattes des ATmega16.

Aufgabe 12.7:

Nebenl¨auﬁgkeiten

(4 + 4 + 4= 12 P)

Visualisieren Sie die Nebenl¨auﬁgkeiten f¨ur Ihre verschiedenen Realisierungsvarianten:

a) Mit Polling

b) Mit externem Interrupt

c) Mit internem Timer-Counter-Interrupt

Zusatzaufgabe 12.8:
(freiwillig)
Erweitern Sie Ihr Programm nun um die ¨Uberlauﬀunktionalit¨at. Bei einem ¨Uberlauf der
Stoppuhr soll eine Sekunde lang auf dem Pin PA2 ein 1-Puls ausgegeben werden.

¨Uberlaufanzeige

Zusatzaufgabe 12.9:

16-Bit-Z¨ahler und Bit-Togglen

(freiwillig)

Das Hauptprogramm soll nun zus¨atzlich eine LED rhythmisch als Alive-LED blinken lassen,
um anzuzeigen, dass die Software auf dem ATmega16 noch korrekt arbeitet. Dabei soll die
Blinkfrequenz durch einen Software-Z¨ahler generiert werden.

a) Schreiben Sie zun¨achst ein seiteneﬀektfreies Makro TOGGLE LED, das bei jedem Aufruf
einen Pin von Port A toggelt, d.h. abwechselnd ein- und ausschaltet. Dabei d¨urfen die
¨ubrigen 7 Bits dieses Ports nicht ver¨andert werden. Die Nummer des Pins, der getoggelt
werden soll, wird als formaler Parameter ¨ubergeben.

b) Erweitern Sie nun das Hauptprogramm, sodass es einen einfachen 16-Bit-Z¨ahler in der
Endlosschleife inkrementiert und bei jedem ¨Uberlauf das Makro TOGGLE LED mit dem
entsprechenden Pin PA3 aufruft, um die Alive-LED blinken zu lassen.

(Hinweis: Um einen 16-Bit-Z¨ahler aus zwei 8-Bit-Registern zusammenzusetzen, k¨onnen
Sie entweder zwei beliebige Register und geschachtelte Abfragen verwenden oder eines
der 16-Bit-Register X, Y, Z und spezielle Befehle.)

c) Mit welcher Frequenz blinkt eine an Pin PA3 angeschlossene LED bei Ihrer Implementie-
rung und einem Prozessortakt von 1 MHz? Vernachl¨assigen Sie f¨ur die Betrachtung die
Laufzeit der Interrupt-Serviceroutinen. Begr¨unden Sie Ihre Antwort durch eine Aufstel-
lung der Ausf¨uhrungszeiten aller beteiligten Befehle und kontrollieren Sie Ihre Antwort
mit Hilfe des Simulators im AVR-Studio.

d) Implementieren Sie auch die je nach Ihrer Wahl andere Variante f¨ur den 16-Bit-Z¨ahler

und vergleichen Sie die Laufzeitunterschiede.

4

