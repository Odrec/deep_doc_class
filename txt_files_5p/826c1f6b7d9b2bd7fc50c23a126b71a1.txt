                 HEURISTIC INTERPRETATION OF PREDICATE LOGIC EXPRESSIONS IN GENERAL GAME PLAYING 
 

 
 
 
 
 
 
 

 
 

 
 

 
 
 

 

 

 
 

 

 

 

 

1 

REVIEW:  

HEURISTIC INTERPRETATION OF PREDICATE LOGIC 

EXPRESSIONS IN GENERAL GAME PLAYING 

DANIEL MICHULKE 

SARA EUSTERGERLING, JUSTIN GÜSE, FELIX WÖBKENBERG 

 

 

 

 

 
 

 
 

   
 

 
Abstract. We provide a summary of the paper by Daniel Michulke focussing on new advances in
heuristic interpretation of predicate logic expressions in General Game Playing. The authors present an
 
alternative method that derives features from the goal conditions stated in the game rules, avoiding
 
 
thereby the disadvantages of other standard General Game Playing approaches.  
 
 

 
 

 
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

1.  Introduction 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

 
 

General Game Playing is dealing with the development of agents that are capable of playing games
 
they have never seen before. They receive the games rules some minutes prior the start of the game and
 
 
automatically construct a state value function to guide search, using game tree search. 
   
In this paper Michulke et al. aim to present a new technique of deriving an evaluation function from a
given domain theory. They present a new starting point for state evaluation without the disadvantages
 
related to standard approaches. Furthermore they managed to apply these features without a costly feature
 
 
evaluation and weighting phase. 
 

 
   

 
 

 
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

2. The Standard Approach 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

As mentioned above, General Game Playing deals with development of agents that are able to play
 

 
games they have never seen before. 
An important part of this progress is the construction of the state evaluation function that evaluates states
 
and guides the agent to states with a high value. There are two basic types of these functions: 
The first function is called Monte Carlo. They evaluate a state by performing random playouts until a
 
   
terminal state is reached. After some of these playouts, the average of the outcomes becomes the state
 
 
value. The disadvantage of this approach is that it assumes a random opponent behaviour and is not able
to challenge informed or non­random opponents in games with well­studied evaluation functions such as
 
Chess. 
The second function is the deterministic evaluation based on the state itself. Agents of this category
 
 
 
derive candidate features from expressions in the game description and evaluate them to obtain a measure
 
 
 
of usefulness for the game and put this all together, sometimes weighted, to construct the evaluation
function. Although it is perfectly reasonable, it is very time­consuming and therefore not useful for the
 
competition setup. 

 
   

 
 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

                 HEURISTIC INTERPRETATION OF PREDICATE LOGIC EXPRESSIONS IN GENERAL GAME PLAYING 
 

 

3. The Improved GGP­Algorithm 

 

 

 

 

 

 

 

 

 
 

 
In the Improved GGP­Algorithm the evaluation function is constructed after receiving
 
 
rules that process goal conditions. Usually the goal condition is formulated in quantified
predicate logic. The algorithm in this paper takes existentially quantified expressions and
 
 
transforms it recursively into a tree like structure that represents the evaluation function. 

 
 
 

 
 
 

 
 

State evaluation is that we use the evaluation tree to obtain a single value that represents
 
a propositional fuzzy evaluation of the goal condition. Finally values are recursively passed
 
 
 
up the evaluation structure. Predicates are defined along with fuzzy logic. 
 

Fuzzy Logic defines basic operations like true, false, and and or. It basically rather
 

   
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

 
 

 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 
 

 
 
 

   
 

 
 
   
 

approximates variables instead of defining them fixed. 
 
 

Ground Instantiation is possible if all variables in the game description are finite.
 
Fortunately they are finite in this case. This Ground Instantiation is done by substituting
 
any expression that contains a variable with the disjunction of the expression where that
 
 
variable is substituted by all the terms in the domain of the variable. In this paper it is used
 
to deal with expressions that can not be expanded any further. This is done by breaking
down variable sharing conjunctions to a disjunction of standard conjunctions. If there is a
 
 
large number of variables the ground instantiation grows exponentially. The solution of
 
 
Michulke et al. is a mixed approach. Furthermore they found out that expressions that are
uninstantiated are directly evaluated by the reasoner. The effect of Ground Instantiation is
 
 
that it makes predicates static, so they do not depend on a state anymore. Another point is
 
 
that it is immediately evaluated without inclusion in the evaluation function.  
 

Expression features deal with the modification or expansion of the algorithm for
 
optimization. This is done by the replacement of further expansion via Ground Instantiation
 
or simple delegation to the reasoner. How is this done? It is done by interpretation directly
 
as a feature. Furthermore by adding features as leaves to the evaluation tree. The effects of
 
this are that no Ground Instantiation is used, so the number of nodes becomes smaller and
 
 
the function becomes faster to evaluate. The resulting feature is more expressive than its
otherwise expanded alternative. All in all it becomes faster and estimates better at the same
 
time. 

 
 
 

 
 
 

 
 
 

 
 
 

 
 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

Solution Cardinality evaluates the expression to false,
 
 

instead of evaluating the
 
expression to true or false, if there are no solutions. But they give it a higher value for the
 
more solutions there are. If the states are relatively stable and the set of true fluents does not
 
 
change, a higher solution cardinality indicates that the expression is more likely to be true in
 
successor states. The results of this is that it becomes much faster because the set of
candidate features is greatly reduced, the size of the evaluation function is now one node
 
instead of nine. Furthermore the correlation to goal values is implicitly determined through
 
the context the fuzzy logic provides. 

   
 
 
 

 
 
 

 
 
 

 
 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

Order is the concept that we identify an expression as order feature if we encounter a
 
 
 
conjunction with sharing variables, where at least one fluent variable occurs in a static
predicate that represents a total order. Furthermore conjunctions with shared variables
 
 
adhere to a number of patterns. An advantage of this is that it is now finer granulated in
 
comparison of elements and the size is reduced by avoiding ground instantiation. As an
 
example states the piece_count predicate in the paper. It has 13 possible values for each
role, which expresses 169 ground evaluations by one heuristic order expression. Against
 
this concept speaks that the authors were not able to see an easy way to express this relation
 
 
while sticking to truth values of fuzzy logic, which leads to a loss of correctness. 
 
 

The pattern of relative distances is applied to with at least two fluents. If two fluents
 
share the same Variables at the same argument positions we can evaluate their distance in
 
our metrical system on their arguments. The return values are based on the distance between
 
the fluents. Close distances mean less effort to get from fluent a to fluent b. Basically there
 

 
 
 

 
 
 

 
 
 

 
 
 

 
 

 
 

 
 

   

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

2 

 

                 HEURISTIC INTERPRETATION OF PREDICATE LOGIC EXPRESSIONS IN GENERAL GAME PLAYING 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

   

 
 

 
 

 
 
   

 
are high return values for lower distances where every argument leads to a legal game state.
There are also predicates (i.e. static predicates) which do not represent a functionalor
 
injective relationship. The domain elements of these predicates cannot be mapped to natural
 
 
numbers therefore they cannot be subjected to the metrical system. For these predicates they
construct a graph where every edge represents a relation between the fluents. In this graph
 
the distance is the shortest path. If there is no distance we have no relationship between the
 
fluents. The longest of all shortest paths provides the strongest relationship between two
 
domain states. To compare 2 fluents in this type of graph they have to be in the exact right
 
 
state otherwise the distance becomes infinite. 

 
 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 

   

 
 

 
 

   
 

 
 
 

 
 
 

 
   
 

Fluent features modify an existing true(Fluent) expression to a more complex evaluation.
 
This evaluation has a rather expensive runtime but it leads to more fine grained results. A
 
 
 
 
fluent feature has a fluent as first argument. The utility of a fluent feature is based on its
 
other arguments. Given a solution cardinality or a variable as following arguments it can be
used to check for game events such as winning or losing conditions. Furthermore Fluent
 
 
features can be used to estimate the distance towards a game event. Therefore the game
 
event has to be represented by a fixed fluent. A fixed fluent is a fluent feature expression
which has a Fluent as its first and constants as following arguments. The constants signify
 
the required values which must be satisfied in order to trigger a certain game event. In order
 
 
to work with it we need to generalize this pattern to all fluents. Afterwards we search for
fluents with accordant arguments at the right positions. If two matching fluents have been
 
 
found the distance between them can be evaluated and the result is the distance which can
 
be used in further evaluations. The closer the distance between a fixed and a non­fixed
 
fluent feature the higher the solution cardinality. 

 
 
 
 

 
 
 

 
 
 
 

 
 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

   

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

Another property of fluent features is persistence. Fluent features are persistent true if
 
 
their current state holds in every successor game state. A persistent true fluent feature can
 
 
be used to speed up equation states in order to reduce the term­time. Persistent true false
 
features in conjunctions negate the whole term while persistent true true features always
 
verify a disjunction.  

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

4. Conclusion 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

 
 

 
 

 
 

Michulke et al. provided a method to transform a predicate logic expression to an
 
evaluation function without an expensive feature evaluation phase. This is done by detecting
 
 
features in the expression and applying algorithms with low termtime to obtain their
information. Prospectively the focus will lay on the runtime and effectiveness of features in
 
 
 
different game scenarios to decide whether it is reasonable to evaluate arguments with a
 
given feature or not. Personally we think the idea behind this strategy is a very effective
 
approach. Avoiding computation time by obtaining information with smaller algorithms is a
   
 
very auspicious design but there are still a lot of optimizations possible. To get to its full
effectiveness this algorithm needs some sort of control unit which can dynamically decide
 
whether features should be applied to a given expression or not. 

 
 
 
 

 
 
 

 
 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 

References 

 

Michulke, Daniel. "Heuristic Interpretation of Predicate Logic Expressions in General Game 
Playing." ­  The IJCAI­11 Workshop on General Game Playing. 2011.  

  Email: seustergerli@uos.de jguese@uos.de fwoebkenberg@uos.de  

3 

 

 

 

 

